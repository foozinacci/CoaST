<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>CoAST – Calculator of All Structural Tuning</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        --bg: #020617;
        --bg-panel: #020617;
        --bg-panel-soft: #020617;
        --accent: #38bdf8;
        --accent-soft: rgba(56, 189, 248, 0.18);
        --accent2: #22c55e;
        --border: #1f2937;
        --text: #e5e7ff;
        --muted: #9ca3c7;
        --danger: #f97373;
        --radius: 12px;

        --curve-mv0: #64748b;
        --curve-mv1: #f97316;
        --curve-mv2: #fb7185;
        --curve-mv3: #a855f7;
        --curve-mv4: #22c55e;
        --curve-mv5: #0ea5e9;
        --curve-mv6: #facc15;
        --curve-mv7: #f97316;
        --curve-mv8: #fb7185;
        --curve-mv9: #a855f7;
        --curve-mv10: #22c55e;
      }

      .theme-light {
        --bg: #f3f4f6;
        --bg-panel: #ffffff;
        --bg-panel-soft: #f9fafb;
        --accent: #2563eb;
        --accent-soft: rgba(37, 99, 235, 0.1);
        --accent2: #16a34a;
        --border: #d1d5db;
        --text: #020617;
        --muted: #6b7280;
      }

      .theme-neon {
        --bg: #020617;
        --bg-panel: #020617;
        --bg-panel-soft: #020617;
        --border: #1e293b;
        --text: #e5e7ff;
        --muted: #9ca3c7;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: radial-gradient(
          circle at top left,
          #0f172a 0,
          #020617 40%,
          #000 100%
        );
        color: var(--text);
      }

      .app-root {
        max-width: 1280px;
        margin: 0 auto;
        padding: 12px;
      }

      h1,
      h2,
      h3 {
        margin: 0 0 0.3em;
      }

      h1 {
        font-size: 1.65rem;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: baseline;
      }

      .logo-coast {
        font-weight: 800;
        letter-spacing: 0.18em;
      }

      .pill {
        font-size: 0.7rem;
        padding: 3px 8px;
        border-radius: 999px;
        border: 1px solid var(--accent-soft);
        color: var(--accent);
        background: rgba(15, 23, 42, 0.9);
      }

      .muted {
        font-size: 0.85rem;
        color: var(--muted);
      }

      button {
        border-radius: 999px;
        border: none;
        padding: 7px 16px;
        font-size: 0.85rem;
        font-weight: 600;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        background: linear-gradient(135deg, var(--accent2), var(--accent));
        color: white;
        box-shadow: 0 10px 22px rgba(15, 23, 42, 0.7);
        transition: transform 0.06s ease, box-shadow 0.06s ease;
      }

      button:hover:not(:disabled) {
        transform: translateY(-1px);
        box-shadow: 0 12px 26px rgba(15, 23, 42, 0.9);
      }

      button:active:not(:disabled) {
        transform: translateY(0);
        box-shadow: 0 8px 18px rgba(15, 23, 42, 0.8);
      }

      button.secondary {
        background: radial-gradient(circle at top left, #020617 0, #020617 55%);
        color: var(--muted);
        border-radius: 999px;
        border: 1px solid var(--border);
        box-shadow: inset 0 0 0 1px #000, 0 10px 22px rgba(0, 0, 0, 0.6);
      }

      button.secondary:hover:not(:disabled) {
        color: var(--text);
        border-color: var(--accent-soft);
      }

      button:disabled {
        opacity: 0.5;
        cursor: default;
        box-shadow: none;
        transform: none;
      }

      input[type="text"],
      input[type="number"],
      select,
      textarea {
        background: var(--bg);
        color: var(--text);
        border-radius: 999px;
        border: 1px solid var(--border);
        padding: 6px 10px;
        font-size: 0.85rem;
        font-family: inherit;
        box-shadow: inset 0 0 0 1px #000,
          inset 0 6px 12px rgba(0, 0, 0, 0.7);
      }

      textarea {
        border-radius: 10px;
        resize: vertical;
      }

      label {
        font-size: 0.8rem;
        color: var(--muted);
      }

      .card {
        border-radius: var(--radius);
        background: radial-gradient(
          circle at top left,
          #0b1220 0,
          var(--bg-panel) 55%
        );
        border: 1px solid var(--border);
        padding: 12px;
        box-shadow: 0 14px 32px rgba(0, 0, 0, 0.55);
      }

      .panel-inset {
        border-radius: var(--radius);
        background: var(--bg-panel-soft);
        border: 1px solid #020617;
        box-shadow: inset 0 0 0 1px #111827,
          inset 0 8px 16px rgba(0, 0, 0, 0.7);
        padding: 10px;
      }

      .panel-raised {
        border-radius: var(--radius);
        background: radial-gradient(
          circle at top left,
          var(--bg-panel) 0,
          var(--bg-panel) 55%
        );
        border: 1px solid #111827;
        box-shadow: 0 12px 26px rgba(15, 23, 42, 0.9);
        padding: 10px;
      }

      .topbar {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        margin-bottom: 8px;
      }

      .topbar-right {
        margin-left: auto;
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }

      .deck-layout {
        display: grid;
        grid-template-columns: minmax(0, 1.1fr) minmax(0, 0.9fr);
        gap: 12px;
        margin-top: 10px;
      }

      .chip {
        font-size: 0.75rem;
        padding: 3px 8px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: radial-gradient(
          circle at top left,
          #020617 0,
          rgba(15, 23, 42, 0.9) 60%
        );
        color: var(--muted);
        box-shadow: 0 5px 11px rgba(0, 0, 0, 0.6);
      }

      .chip-ok {
        border-color: var(--accent2);
        color: var(--accent2);
      }
      .chip-warn {
        border-color: #facc15;
        color: #facc15;
      }
      .chip-bad {
        border-color: #ef4444;
        color: #ef4444;
      }

      .deck-toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        justify-content: space-between;
        margin: 8px 0 4px;
      }

      .deck-container {
        background: rgba(15, 23, 42, 0.9);
        border-radius: 10px;
        border: 1px solid var(--border);
        max-height: 360px;
        overflow: auto;
        padding: 6px;
      }

      .deck-list-row {
        display: grid;
        grid-template-columns: 52px minmax(0, 1.6fr) minmax(0, 1.1fr) 60px;
        gap: 6px;
        padding: 4px 4px;
        font-size: 0.8rem;
        align-items: center;
        border-radius: 6px;
      }

      .deck-list-row:nth-child(odd) {
        background: rgba(15, 23, 42, 0.9);
      }

      .qty-pill {
        font-size: 0.75rem;
        padding: 2px 7px;
        border-radius: 999px;
        border: 1px solid #1f2937;
        background: rgba(15, 23, 42, 0.9);
        box-shadow: inset 0 0 0 1px #000;
      }

      .pip {
        width: 14px;
        height: 14px;
        border-radius: 999px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 0.7rem;
        border: 1px solid #020617;
      }

      .pip-W {
        background: #f9fafb;
        color: #0f172a;
      }
      .pip-U {
        background: #0ea5e9;
        color: #020617;
      }
      .pip-B {
        background: #020617;
        color: #e5e7eb;
      }
      .pip-R {
        background: #ef4444;
        color: #111827;
      }
      .pip-G {
        background: #16a34a;
        color: #022c22;
      }
      .pip-C {
        background: #9ca3af;
        color: #111827;
      }

      .summary-panel {
        background: rgba(15, 23, 42, 0.95);
        border-radius: 10px;
        border: 1px solid var(--border);
        padding: 8px;
        max-height: 260px;
        overflow: auto;
        font-size: 0.8rem;
      }

      .summary-tabs,
      .plan-tabs {
        display: flex;
        flex-wrap: nowrap;
        gap: 6px;
        margin: 4px 0 6px;
        overflow-x: auto;
      }

      .summary-tab-btn,
      .plan-tab-btn {
        border-radius: 999px;
        border: 1px solid var(--border);
        background: radial-gradient(
          circle at top left,
          #020617 0,
          rgba(15, 23, 42, 0.9) 60%
        );
        color: var(--muted);
        font-size: 0.75rem;
        padding: 3px 9px;
        flex-shrink: 0;
        cursor: pointer;
        box-shadow: 0 6px 14px rgba(0, 0, 0, 0.8);
      }

      .summary-tab-btn.active,
      .plan-tab-btn.active {
        border-color: var(--accent);
        color: var(--accent);
        box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.6),
          0 10px 22px rgba(0, 0, 0, 0.9);
      }

      .summary-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }

      .summary-chip {
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: rgba(15, 23, 42, 0.9);
        font-size: 0.75rem;
      }

      .summary-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.75rem;
      }

      .summary-table th,
      .summary-table td {
        border-bottom: 1px solid rgba(15, 23, 42, 0.8);
        padding: 3px 4px;
        text-align: right;
        white-space: nowrap;
      }

      .summary-table th:first-child,
      .summary-table td:first-child {
        text-align: left;
      }

      .summary-table tr:last-child th,
      .summary-table tr:last-child td {
        border-bottom: none;
      }

      .curve-bar-row {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-bottom: 3px;
      }

      .curve-bar-label {
        width: 26px;
        font-size: 0.75rem;
      }

      .curve-bar-track {
        flex: 1;
        height: 10px;
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.9);
        overflow: hidden;
        position: relative;
      }

      .curve-bar-actual,
      .curve-bar-anchor {
        position: absolute;
        top: 0;
        bottom: 0;
      }

      .curve-bar-actual {
        left: 0;
        background: linear-gradient(
          90deg,
          var(--curve-mv1),
          var(--curve-mv3),
          var(--curve-mv5)
        );
      }

      .curve-bar-anchor {
        right: 0;
        background: rgba(148, 163, 184, 0.55);
      }

      .curve-bar-counts {
        width: 100px;
        text-align: right;
        font-size: 0.7rem;
      }

      .side-by-side {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .side-panel {
        flex: 1 1 200px;
      }

      .row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        margin-bottom: 6px;
      }

      .toast {
        position: fixed;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(15, 23, 42, 0.98);
        color: var(--text);
        border-radius: 999px;
        border: 1px solid var(--border);
        padding: 7px 14px;
        font-size: 0.8rem;
        box-shadow: 0 10px 26px rgba(0, 0, 0, 0.8);
        z-index: 50;
      }

      .diagnostics {
        margin-top: 6px;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid rgba(248, 250, 252, 0.1);
        background: radial-gradient(
          circle at top left,
          rgba(148, 163, 184, 0.35) 0,
          rgba(15, 23, 42, 0.95) 45%
        );
        font-size: 0.7rem;
        color: #fbbf24;
        display: inline-flex;
        gap: 10px;
        align-items: center;
      }

      .diagnostics.ok {
        color: #22c55e;
      }

      .diagnostics span {
        white-space: nowrap;
      }

      .handlab-container {
        margin-top: 10px;
        display: grid;
        grid-template-columns: minmax(0, 1.4fr) minmax(0, 1.1fr);
        gap: 10px;
      }

      .hand-card-pill {
        border-radius: 8px;
        border: 1px solid var(--border);
        padding: 3px 6px;
        font-size: 0.75rem;
        background: rgba(15, 23, 42, 0.95);
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 4px;
      }

      .tag-chip {
        font-size: 0.65rem;
        border-radius: 999px;
        padding: 1px 5px;
        border: 1px solid var(--border);
        background: rgba(15, 23, 42, 0.95);
      }

      .life-counter {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 3px 8px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: radial-gradient(
          circle at top left,
          #020617 0,
          rgba(15, 23, 42, 0.95) 60%
        );
        font-size: 0.75rem;
      }

      .life-counter button {
        padding: 2px 7px;
        font-size: 0.75rem;
        box-shadow: inset 0 0 0 1px #000,
          0 4px 10px rgba(0, 0, 0, 0.8);
      }

      .life-counter span {
        min-width: 20px;
        text-align: center;
      }

      @media (max-width: 900px) {
        .deck-layout {
          grid-template-columns: 1fr;
        }
        .deck-container {
          max-height: none;
        }
        .summary-panel {
          max-height: none;
        }
        h1 {
          flex-direction: column;
          align-items: flex-start;
        }
        .handlab-container {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <!-- React + ReactDOM + Babel from CDN -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- CoAST app -->
    <script type="text/babel">
      const { useState, useEffect, useMemo } = React;

      /* ---------------------- math helpers / hypergeometric ---------------------- */

      function comb(n, k) {
        if (k < 0 || k > n) return 0;
        if (k === 0 || k === n) return 1;
        k = Math.min(k, n - k);
        let res = 1;
        for (let i = 1; i <= k; i++) {
          res = (res * (n - k + i)) / i;
        }
        return res;
      }

      function hyperPMF(k, K, N, n) {
        if (n > N) return 0;
        const num = comb(K, k) * comb(N - K, n - k);
        const den = comb(N, n);
        return den === 0 ? 0 : num / den;
      }

      function probAtLeast(k, K, N, n) {
        let p = 0;
        const maxK = Math.min(K, n);
        for (let i = k; i <= maxK; i++) p += hyperPMF(i, K, N, n);
        return p;
      }

      function pct(p) {
        if (!Number.isFinite(p)) return "0.0%";
        return (p * 100).toFixed(1) + "%";
      }

      /* ----------------------------- anchor curves ----------------------------- */

      const ANCHOR_CURVES = {
        40: { 16: { 1: 6, 2: 12, 3: 6 } },
        60: { 24: { 1: 10, 2: 14, 3: 7, 4: 5, 5: 3, 6: 1 } },
        99: { 35: { 1: 5, 2: 12, 3: 13, 4: 10, 5: 7, 6: 5, 7: 3, 8: 1 } }
      };

      function getAnchor(sizeBucket, landCount) {
        const entry = ANCHOR_CURVES[sizeBucket];
        if (!entry) return null;
        if (entry[landCount]) return entry[landCount];
        const keys = Object.keys(entry).map((x) => parseInt(x, 10));
        if (!keys.length) return null;
        let nearest = keys[0];
        for (const k of keys) {
          if (Math.abs(k - landCount) < Math.abs(nearest - landCount)) nearest = k;
        }
        return entry[nearest];
      }

      /* ------------------------------- Scryfall ------------------------------- */

      const scryfallCache = new Map();

      async function fetchCardData(name) {
        const key = name.toLowerCase();
        if (scryfallCache.has(key)) return scryfallCache.get(key);
        try {
          const resp = await fetch(
            "https://api.scryfall.com/cards/named?fuzzy=" +
              encodeURIComponent(name)
          );
          if (!resp.ok) throw new Error("Scryfall error");
          const data = await resp.json();
          let image = null;
          if (data.image_uris?.normal) image = data.image_uris.normal;
          else if (
            Array.isArray(data.card_faces) &&
            data.card_faces[0]?.image_uris?.normal
          ) {
            image = data.card_faces[0].image_uris.normal;
          }
          const info = {
            name: data.name || name,
            cmc: data.cmc || 0,
            type_line: data.type_line || "Unknown",
            mana_cost: data.mana_cost || "",
            color_identity: data.color_identity || [],
            image_url: image
          };
          scryfallCache.set(key, info);
          return info;
        } catch (e) {
          const info = {
            name,
            cmc: 0,
            type_line: "Unknown",
            mana_cost: "",
            color_identity: [],
            image_url: null
          };
          scryfallCache.set(key, info);
          return info;
        }
      }

      /* --------------------------- localStorage keys -------------------------- */

      const STORAGE_KEY = "coast_decks_v2";

      function loadAllDecks() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return {};
          const obj = JSON.parse(raw);
          return typeof obj === "object" && obj ? obj : {};
        } catch {
          return {};
        }
      }

      function saveAllDecks(obj) {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(obj));
      }

      /* ------------------------------ small utils ----------------------------- */

      function detectFormat(deckSize) {
        if (deckSize >= 35 && deckSize <= 50) return 40;
        if (deckSize >= 51 && deckSize <= 75) return 60;
        if (deckSize >= 90 && deckSize <= 110) return 99;
        return null;
      }

      function pipColorCounts(cardInfos) {
        const pipTotals = {};
        const pipRegex = /\{([WUBRG])\}/g;
        for (const c of cardInfos) {
          const cost = c.mana_cost || "";
          let m;
          while ((m = pipRegex.exec(cost)) !== null) {
            pipTotals[m[1]] = (pipTotals[m[1]] || 0) + c.qtyMain;
          }
        }
        return pipTotals;
      }

      function manaSourcesFromLands(cardInfos) {
        const landSources = {};
        for (const c of cardInfos) {
          const isLand = (c.type_line || "").toLowerCase().includes("land");
          if (!isLand) continue;
          for (const col of c.color_identity || []) {
            landSources[col] = (landSources[col] || 0) + c.qtyMain;
          }
        }
        return landSources;
      }

      function buildMainDeckInstances(cardInfos) {
        const inst = [];
        let id = 1;
        for (const c of cardInfos) {
          for (let i = 0; i < c.qtyMain; i++) {
            inst.push({ id: id++, name: c.name, ref: c });
          }
        }
        return inst;
      }

      function shuffleInPlace(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
      }

      function parseDeckText(text) {
        const LINE_RE = /^\s*(\d+)[xX]?\s+(.+?)\s*$/;
        const entries = {};
        let currentZone = "main";
        text
          .split(/\r?\n/)
          .map((l) => l.trim())
          .forEach((line) => {
            if (!line) return;
            if (line.toLowerCase() === "sideboard") {
              currentZone = "side";
              return;
            }
            if (line.startsWith("//") || line.startsWith("#")) return;
            const m = line.match(LINE_RE);
            if (!m) return;
            const qty = parseInt(m[1], 10);
            const name = m[2];
            if (!Number.isFinite(qty) || !name) return;
            if (!entries[name]) entries[name] = { qtyMain: 0, qtySide: 0 };
            if (currentZone === "side") entries[name].qtySide += qty;
            else entries[name].qtyMain += qty;
          });
        return entries;
      }

      function entriesToText(entries) {
        const mainLines = [];
        const sideLines = [];
        for (const [name, z] of Object.entries(entries)) {
          if (z.qtyMain) mainLines.push(`${z.qtyMain} ${name}`);
          if (z.qtySide) sideLines.push(`${z.qtySide} ${name}`);
        }
        mainLines.sort();
        sideLines.sort();
        if (sideLines.length) {
          return mainLines.join("\n") + "\n\nSideboard\n" + sideLines.join("\n");
        }
        return mainLines.join("\n");
      }

      /* ----------------------------- React app ----------------------------- */

      const DEFAULT_DECK_TEXT = `4 Llanowar Elves
4 Heaped Harvest
3 Toph, the First Metalbender
3 Mossborn Hydra
3 Twinmaw Stormbrood
3 Famished Worldsire
3 Glacier Godmaw
4 Cycle of Renewal
4 Smuggler's Surprise
8 Forest
4 Stomping Ground
4 Hushwood Verge
3 Multiversal Passage
1 Mountain
1 Plains

Sideboard
2 Ghalta, Stampede Tyrant`;

      function App() {
        const [allDecks, setAllDecks] = useState(() => {
          const loaded = loadAllDecks();
          if (Object.keys(loaded).length) return loaded;
          // seed with one default deck
          return {
            "Earthbend Harvest": {
              name: "Earthbend Harvest",
              rawText: DEFAULT_DECK_TEXT
            }
          };
        });

        const deckIds = Object.keys(allDecks);
        const [currentDeckId, setCurrentDeckId] = useState(
          deckIds[0] || "Earthbend Harvest"
        );

        const [editorText, setEditorText] = useState(() => {
          const d = allDecks[currentDeckId];
          return d?.rawText || DEFAULT_DECK_TEXT;
        });

        const [cards, setCards] = useState([]);
        const [activeSummaryTab, setActiveSummaryTab] = useState("overview");
        const [activePlan, setActivePlan] = useState("Game 1");
        const [planNames, setPlanNames] = useState(["Game 1", "Postboard"]);
        const [mulliganStyle, setMulliganStyle] = useState("london");
        const [life, setLife] = useState(20);
        const [toast, setToast] = useState(null);
        const [handState, setHandState] = useState({
          library: [],
          hand: [],
          bottom: [],
          exile: [],
          graveyard: [],
          mulligans: 0,
          keeps: 0,
          samples: 0
        });
        const [diagnostics, setDiagnostics] = useState({
          ok: true,
          messages: ["Idle"]
        });

        /* ----------------------------- persistence ----------------------------- */

        useEffect(() => {
          setAllDecks((prev) => {
            const copy = { ...prev };
            const current =
              copy[currentDeckId] || { name: currentDeckId, rawText: "" };
            current.rawText = editorText;
            copy[currentDeckId] = current;
            saveAllDecks(copy);
            return copy;
          });
        }, [editorText, currentDeckId]);

        /* ------------------------------ deck parse ------------------------------ */

        async function syncFromText() {
          const parsed = parseDeckText(editorText || "");
          const names = Object.keys(parsed);
          if (!names.length) {
            setCards([]);
            setToast("Deck cleared (no parseable lines).");
            return;
          }

          const existingByName = {};
          for (const c of cards) existingByName[c.name.toLowerCase()] = c;

          const promises = names.map(async (name) => {
            const z = parsed[name];
            const lower = name.toLowerCase();
            let base = existingByName[lower];
            if (!base) {
              const info = await fetchCardData(name);
              base = {
                name: info.name,
                cmc: info.cmc || 0,
                type_line: info.type_line || "Unknown",
                mana_cost: info.mana_cost || "",
                color_identity: info.color_identity || [],
                image_url: info.image_url || null,
                qtyMain: 0,
                qtySide: 0,
                tags: { rampVirtual: 0 },
                weights: {}
              };
            }
            return {
              ...base,
              qtyMain: z.qtyMain || 0,
              qtySide: z.qtySide || 0
            };
          });

          const newCards = await Promise.all(promises);
          newCards.sort((a, b) => a.name.localeCompare(b.name));
          setCards(newCards);
          setToast("Deck synced & analysed.");
        }

        function copyDeckToClipboard() {
          try {
            const entries = {};
            for (const c of cards) {
              if (!entries[c.name]) entries[c.name] = { qtyMain: 0, qtySide: 0 };
              entries[c.name].qtyMain += c.qtyMain;
              entries[c.name].qtySide += c.qtySide;
            }
            const txt = entriesToText(entries);
            navigator.clipboard.writeText(txt);
            setToast("Decklist copied to clipboard.");
          } catch (e) {
            setToast("Clipboard unavailable – select & copy manually.");
          }
        }

        function updateVirtualSources(name, value) {
          const v = Math.max(0, Number(value) || 0);
          setCards((prev) =>
            prev.map((c) =>
              c.name === name
                ? { ...c, tags: { ...c.tags, rampVirtual: v } }
                : c
            )
          );
        }

        function updatePlanWeight(name, plan, value) {
          const v = Math.max(0, Number(value) || 0);
          setCards((prev) =>
            prev.map((c) => {
              if (c.name !== name) return c;
              const weights = { ...(c.weights || {}) };
              weights[plan] = v;
              return { ...c, weights };
            })
          );
        }

        function addPlan() {
          const base = "Plan ";
          let i = 1;
          while (planNames.includes(base + i)) i++;
          const newName = base + i;
          const next = [...planNames, newName];
          setPlanNames(next);
          setActivePlan(newName);
        }

        function renameCurrentDeck(newName) {
          const trimmed = newName.trim();
          if (!trimmed) return;
          setAllDecks((prev) => {
            const copy = { ...prev };
            const current = copy[currentDeckId] || {
              name: trimmed,
              rawText: editorText
            };
            delete copy[currentDeckId];
            copy[trimmed] = { ...current, name: trimmed };
            saveAllDecks(copy);
            return copy;
          });
          setCurrentDeckId(trimmed);
        }

        function newBlankDeck() {
          const base = "New Deck ";
          let i = 1;
          const ids = Object.keys(allDecks);
          while (ids.includes(base + i)) i++;
          const id = base + i;
          const updated = {
            ...allDecks,
            [id]: { name: id, rawText: "" }
          };
          setAllDecks(updated);
          saveAllDecks(updated);
          setCurrentDeckId(id);
          setEditorText("");
          setCards([]);
        }

        function deleteDeck(id) {
          const ids = Object.keys(allDecks);
          if (ids.length <= 1) return;
          const copy = { ...allDecks };
          delete copy[id];
          const nextId = Object.keys(copy)[0];
          setAllDecks(copy);
          saveAllDecks(copy);
          setCurrentDeckId(nextId);
          setEditorText(copy[nextId].rawText || "");
          setCards([]);
        }

        /* ------------------------------ stats / memo ----------------------------- */

        const stats = useMemo(() => {
          let totalMain = 0;
          let totalSide = 0;
          let landCount = 0;
          let nonLandCount = 0;
          const cmcCounts = {};
          const cmcWeights = {};
          const colors = { W: 0, U: 0, B: 0, R: 0, G: 0, C: 0 };

          for (const c of cards) {
            totalMain += c.qtyMain;
            totalSide += c.qtySide;
            const isLand = (c.type_line || "").toLowerCase().includes("land");
            if (isLand) landCount += c.qtyMain;
            else nonLandCount += c.qtyMain;

            const baseCmc = Number(c.cmc || 0);
            const weightCmc =
              (c.weights && c.weights[activePlan]) ?? baseCmc;
            const bucket = Math.min(10, Math.max(0, Math.round(baseCmc)));
            const bucketW = Math.min(10, Math.max(0, Math.round(weightCmc)));
            cmcCounts[bucket] = (cmcCounts[bucket] || 0) + c.qtyMain;
            cmcWeights[bucketW] = (cmcWeights[bucketW] || 0) + c.qtyMain;

            const pipRegex = /\{([WUBRG])\}/g;
            let m;
            while ((m = pipRegex.exec(c.mana_cost || "")) !== null) {
              const col = m[1];
              colors[col] += c.qtyMain;
            }
            if ((c.mana_cost || "").includes("{C}")) colors.C += c.qtyMain;
          }

          const formatBucket = detectFormat(totalMain);
          const anchor =
            formatBucket && landCount
              ? getAnchor(formatBucket, landCount)
              : null;

          const pipTotals = pipColorCounts(cards);
          const landSources = manaSourcesFromLands(cards);
          const virtualSources = cards.reduce(
            (sum, c) => sum + (c.tags?.rampVirtual || 0) * c.qtyMain,
            0
          );

          return {
            totalMain,
            totalSide,
            landCount,
            nonLandCount,
            cmcCounts,
            cmcWeights,
            formatBucket,
            anchor,
            pipTotals,
            landSources,
            virtualSources
          };
        }, [cards, activePlan]);

        /* ------------------------------ diagnostics ------------------------------ */

        useEffect(() => {
          const msgs = [];
          let ok = true;
          if (!cards.length) {
            msgs.push("No cards loaded.");
          } else {
            if (stats.formatBucket === null) {
              ok = false;
              msgs.push("Deck size is off-format (expected ~40, 60 or 99).");
            }
            if (stats.landCount === 0) {
              ok = false;
              msgs.push("No lands detected.");
            }
            const bad = cards.filter((c) => c.cmc === 0 && !c.mana_cost);
            if (bad.length) {
              msgs.push(
                `Metadata fallback used for ${bad.length} card(s).`
              );
            }
            if (stats.totalSide > 15) {
              msgs.push(
                `Sideboard has ${stats.totalSide} cards (over 15).`
              );
            }
            if (!msgs.length) {
              msgs.push("Deck passes basic sanity checks.");
            }
          }
          msgs.push(`Mulligan: ${mulliganStyle.toUpperCase()}`);
          setDiagnostics({ ok, messages: msgs });
        }, [cards, stats, mulliganStyle]);

        /* ------------------------------ hand lab ------------------------------ */

        function resetLibraryAndHand() {
          const inst = buildMainDeckInstances(cards);
          if (!inst.length) {
            setToast("No main deck to draw from.");
            return;
          }
          shuffleInPlace(inst);
          const handSize = 7;
          const hand = inst.splice(0, handSize);
          setHandState({
            library: inst,
            hand,
            bottom: [],
            exile: [],
            graveyard: [],
            mulligans: 0,
            keeps: 0,
            samples: 1
          });
          setLife(20);
        }

        function drawCard() {
          setHandState((prev) => {
            if (!prev.library.length && !prev.bottom.length) return prev;
            const lib = [...prev.library];
            const bottom = [...prev.bottom];
            let drawn;
            if (lib.length) drawn = lib.shift();
            else drawn = bottom.shift();
            const hand = [...prev.hand, drawn];
            return { ...prev, library: lib, bottom, hand };
          });
        }

        function tagCardZone(cardId, zone) {
          setHandState((prev) => {
            let { hand, library, bottom, exile, graveyard } = prev;
            const all = { hand, library, bottom, exile, graveyard };
            let card = null;
            for (const key of Object.keys(all)) {
              const idx = all[key].findIndex((c) => c.id === cardId);
              if (idx >= 0) {
                card = all[key][idx];
                all[key] = [
                  ...all[key].slice(0, idx),
                  ...all[key].slice(idx + 1)
                ];
                break;
              }
            }
            if (!card) return prev;
            if (zone === "hand") all.hand = [...all.hand, card];
            else if (zone === "library-top")
              all.library = [card, ...all.library];
            else if (zone === "library-bottom")
              all.bottom = [...all.bottom, card];
            else if (zone === "exile") all.exile = [...all.exile, card];
            else if (zone === "graveyard")
              all.graveyard = [...all.graveyard, card];
            return {
              ...prev,
              hand: all.hand,
              library: all.library,
              bottom: all.bottom,
              exile: all.exile,
              graveyard: all.graveyard
            };
          });
        }

        function mulliganHand() {
          setHandState((prev) => {
            const inst = buildMainDeckInstances(cards);
            if (!inst.length) return prev;
            shuffleInPlace(inst);
            const nextMull = prev.mulligans + 1;
            const baseHandSize = 7;
            const handSize =
              mulliganStyle === "none"
                ? baseHandSize
                : Math.max(0, baseHandSize - nextMull);
            const hand = inst.splice(0, handSize);
            return {
              library: inst,
              hand,
              bottom: [],
              exile: [],
              graveyard: [],
              mulligans: nextMull,
              keeps: prev.keeps,
              samples: prev.samples + 1
            };
          });
          setLife(20);
        }

        function keepHand() {
          setHandState((prev) => ({
            ...prev,
            keeps: prev.keeps + 1
          }));
        }

        function resetHandLab() {
          setHandState({
            library: [],
            hand: [],
            bottom: [],
            exile: [],
            graveyard: [],
            mulligans: 0,
            keeps: 0,
            samples: 0
          });
          setLife(20);
        }

        const handStats = useMemo(() => {
          if (!handState.samples) return null;
          const keepRate = handState.keeps / handState.samples;
          return {
            keepRate
          };
        }, [handState]);

        function nextCopyProbFor(cardName) {
          const totalInDeck = cards.find((c) => c.name === cardName)?.qtyMain;
          if (!totalInDeck) return 0;
          const inHand = handState.hand.filter(
            (c) => c.name === cardName
          ).length;
          const remaining = totalInDeck - inHand;
          if (remaining <= 0) return 0;
          const deckRemaining =
            handState.library.length + handState.bottom.length;
          if (deckRemaining <= 0) return 0;
          return remaining / deckRemaining;
        }

        /* ----------------------------- source odds ----------------------------- */

        const sourceOddsRows = useMemo(() => {
          if (!stats.totalMain) return [];
          const N = stats.totalMain;
          const K = stats.landCount + stats.virtualSources;
          const rows = [];
          for (let turn = 1; turn <= 5; turn++) {
            const cardsSeen = 7 + (turn - 1);
            const need = turn;
            const p = probAtLeast(need, K, N, cardsSeen);
            rows.push({ turn, cardsSeen, need, p });
          }
          return rows;
        }, [stats]);

        /* ------------------------------ toasts ------------------------------ */

        useEffect(() => {
          if (!toast) return;
          const id = setTimeout(() => setToast(null), 2500);
          return () => clearTimeout(id);
        }, [toast]);

        /* ------------------------------- render ------------------------------- */

        const deckName = currentDeckId;

        return (
          <div className="app-root">
            <div className="topbar">
              <h1>
                <span className="logo-coast">CoAST</span>
                <span className="pill">
                  Calculator of All Structural Tuning
                </span>
              </h1>
              <div className="topbar-right">
                <select
                  value={currentDeckId}
                  onChange={(e) => {
                    const id = e.target.value;
                    setCurrentDeckId(id);
                    setEditorText(allDecks[id]?.rawText || "");
                    setCards([]);
                  }}
                >
                  {Object.keys(allDecks).map((id) => (
                    <option key={id} value={id}>
                      {allDecks[id].name || id}
                    </option>
                  ))}
                </select>
                <button
                  className="secondary"
                  onClick={newBlankDeck}
                  title="New empty deck"
                >
                  + New deck
                </button>
                <button
                  className="secondary"
                  disabled={Object.keys(allDecks).length <= 1}
                  onClick={() => deleteDeck(currentDeckId)}
                  title="Delete current deck"
                >
                  Delete
                </button>
              </div>
            </div>

            <div className="muted" style={{ marginBottom: 6 }}>
              Build and tag your list, then hit <strong>Sync &amp; Analyse</strong>.
              The app runs internal sanity checks and updates probabilities,
              curves, and source odds in real time. One saved file: this page.
            </div>

            <div className="deck-layout">
              {/* LEFT: deck editor & list */}
              <div className="card panel-raised">
                <div className="deck-toolbar">
                  <div className="row">
                    <label>
                      Deck name:&nbsp;
                      <input
                        type="text"
                        value={deckName}
                        onChange={(e) => renameCurrentDeck(e.target.value)}
                        style={{ minWidth: 140 }}
                      />
                    </label>
                  </div>
                  <div className="row">
                    <button onClick={syncFromText}>Sync &amp; Analyse</button>
                    <button
                      className="secondary"
                      onClick={copyDeckToClipboard}
                      title="Copy deck & sideboard as text"
                    >
                      Copy decklist
                    </button>
                  </div>
                </div>

                <div className="side-by-side">
                  <div className="side-panel">
                    <label>Deck text (main + “Sideboard” section):</label>
                    <textarea
                      value={editorText}
                      onChange={(e) => setEditorText(e.target.value)}
                      rows={14}
                      style={{ width: "100%", marginTop: 4 }}
                      spellCheck="false"
                    />
                    <div
                      className="muted"
                      style={{ marginTop: 4, fontSize: "0.75rem" }}
                    >
                      Example format:
                      <br />
                      <code>4 Card Name</code>
                      <br />
                      …
                      <br />
                      <code>Sideboard</code>
                      <br />
                      <code>3 Other Card</code>
                    </div>
                  </div>

                  <div className="side-panel">
                    <div className="deck-container">
                      <div
                        className="deck-list-row"
                        style={{
                          fontWeight: 600,
                          borderBottom: "1px solid #111827"
                        }}
                      >
                        <div>Qty</div>
                        <div>Card</div>
                        <div>Tags &amp; weights ({activePlan})</div>
                        <div>CMC</div>
                      </div>
                      {cards.map((c) => (
                        <div
                          key={c.name}
                          className="deck-list-row"
                          title={c.type_line}
                        >
                          <div>
                            <span className="qty-pill">
                              {c.qtyMain}
                              {c.qtySide ? ` +${c.qtySide}` : ""}
                            </span>
                          </div>
                          <div>{c.name}</div>
                          <div>
                            <div className="row">
                              <span className="tag-chip">
                                {c.type_line.includes("Land") ? "Land" : "Spell"}
                              </span>
                              <span className="tag-chip">
                                Virtual land:{" "}
                                <input
                                  type="number"
                                  value={c.tags?.rampVirtual || 0}
                                  min="0"
                                  style={{
                                    width: 40,
                                    fontSize: "0.7rem"
                                  }}
                                  onChange={(e) =>
                                    updateVirtualSources(c.name, e.target.value)
                                  }
                                />
                              </span>
                            </div>
                            <div className="row">
                              <span className="tag-chip">
                                {activePlan} CMC:{" "}
                                <input
                                  type="number"
                                  value={
                                    (c.weights && c.weights[activePlan]) ??
                                    c.cmc
                                  }
                                  min="0"
                                  style={{
                                    width: 46,
                                    fontSize: "0.7rem"
                                  }}
                                  onChange={(e) =>
                                    updatePlanWeight(
                                      c.name,
                                      activePlan,
                                      e.target.value
                                    )
                                  }
                                />
                              </span>
                            </div>
                          </div>
                          <div>{c.cmc}</div>
                        </div>
                      ))}
                      {!cards.length && (
                        <div
                          style={{
                            padding: 8,
                            fontSize: "0.8rem",
                            color: "#9ca3c7"
                          }}
                        >
                          Paste a decklist on the left, then press{" "}
                          <strong>Sync &amp; Analyse</strong>.
                        </div>
                      )}
                    </div>
                  </div>
                </div>

                <div className="row" style={{ marginTop: 8 }}>
                  <div className="life-counter">
                    <span>Life</span>
                    <button onClick={() => setLife((v) => Math.max(0, v - 1))}>
                      -
                    </button>
                    <span>{life}</span>
                    <button onClick={() => setLife((v) => v + 1)}>+</button>
                  </div>
                  <span className="muted">
                    Quick life total stub for painlands & self-testing. Resets
                    when a new hand is generated.
                  </span>
                </div>

                <div>
                  <div
                    className={
                      "diagnostics " + (diagnostics.ok ? "ok" : "")
                    }
                  >
                    {diagnostics.messages.map((m, i) => (
                      <span key={i}>{m}</span>
                    ))}
                  </div>
                </div>
              </div>

              {/* RIGHT: summary & plans */}
              <div className="card panel-inset">
                <div className="row" style={{ marginBottom: 4 }}>
                  <h3 style={{ margin: 0 }}>Summary &amp; Plans</h3>
                  <div style={{ marginLeft: "auto" }}>
                    <span className="chip">
                      Size: {stats.totalMain} main / {stats.totalSide} side
                    </span>{" "}
                    <span className="chip">
                      Lands: {stats.landCount} • Non-lands: {stats.nonLandCount}
                    </span>
                  </div>
                </div>

                <div className="plan-tabs">
                  {planNames.map((p) => (
                    <button
                      key={p}
                      className={
                        "plan-tab-btn " +
                        (p === activePlan ? "active" : "")
                      }
                      onClick={() => setActivePlan(p)}
                    >
                      {p}
                    </button>
                  ))}
                  <button
                    className="plan-tab-btn"
                    onClick={addPlan}
                    title="Add another plan (e.g., post-board)"
                  >
                    +
                  </button>
                </div>

                <div className="summary-tabs">
                  {["overview", "sources", "colors", "curve", "hand"].map(
                    (id) => (
                      <button
                        key={id}
                        className={
                          "summary-tab-btn " +
                          (activeSummaryTab === id ? "active" : "")
                        }
                        onClick={() => setActiveSummaryTab(id)}
                      >
                        {id === "overview" && "Overview"}
                        {id === "sources" && "Source odds"}
                        {id === "colors" && "Color pips"}
                        {id === "curve" && "Curve vs anchor"}
                        {id === "hand" && "Hand lab"}
                      </button>
                    )
                  )}
                </div>

                <div className="summary-panel">
                  {activeSummaryTab === "overview" && (
                    <OverviewTab stats={stats} cards={cards} />
                  )}
                  {activeSummaryTab === "sources" && (
                    <SourcesTab stats={stats} rows={sourceOddsRows} />
                  )}
                  {activeSummaryTab === "colors" && (
                    <ColorsTab stats={stats} />
                  )}
                  {activeSummaryTab === "curve" && (
                    <CurveTab stats={stats} />
                  )}
                  {activeSummaryTab === "hand" && (
                    <HandSummaryTab
                      handState={handState}
                      handStats={handStats}
                      mulliganStyle={mulliganStyle}
                      setMulliganStyle={setMulliganStyle}
                      resetLibraryAndHand={resetLibraryAndHand}
                      mulliganHand={mulliganHand}
                      keepHand={keepHand}
                      resetHandLab={resetHandLab}
                      drawCard={drawCard}
                      nextCopyProbFor={nextCopyProbFor}
                      tagCardZone={tagCardZone}
                    />
                  )}
                </div>
              </div>
            </div>

            {toast && <div className="toast">{toast}</div>}
          </div>
        );
      }

      /* --------------------------- Summary sub-views --------------------------- */

      function OverviewTab({ stats, cards }) {
        if (!cards.length) {
          return (
            <div className="muted">
              Overview will populate once a deck is synced.
            </div>
          );
        }

        const landRatio =
          stats.totalMain > 0
            ? (stats.landCount / stats.totalMain) * 100
            : 0;

        return (
          <div>
            <div className="summary-grid" style={{ marginBottom: 6 }}>
              <div className="summary-chip">
                <strong>{stats.totalMain}</strong> cards main &nbsp;•&nbsp;
                <strong>{stats.landCount}</strong> lands (
                {landRatio.toFixed(1)}%)
              </div>
              <div className="summary-chip">
                <strong>{stats.totalSide}</strong> cards in sideboard
              </div>
              {stats.formatBucket && (
                <div className="summary-chip">
                  Format bucket: <strong>{stats.formatBucket}</strong>
                  &nbsp;deck
                </div>
              )}
              <div className="summary-chip">
                Virtual land sources tagged:{" "}
                <strong>{stats.virtualSources}</strong>
              </div>
            </div>
            <div className="muted" style={{ fontSize: "0.75rem" }}>
              This tab is intentionally compact. The real work is happening in
              the other views – especially Source odds, Colors, Curve, and Hand
              lab – which all update live off the same data.
            </div>
          </div>
        );
      }

      function SourcesTab({ stats, rows }) {
        if (!rows.length) {
          return (
            <div className="muted">
              Source odds need a non-empty main deck with lands.
            </div>
          );
        }

        const totalSources = stats.landCount + stats.virtualSources;

        return (
          <div>
            <div className="summary-grid" style={{ marginBottom: 6 }}>
              <div className="summary-chip">
                Real lands: <strong>{stats.landCount}</strong>
              </div>
              <div className="summary-chip">
                Virtual sources (ramp etc.):{" "}
                <strong>{stats.virtualSources}</strong>
              </div>
              <div className="summary-chip">
                Total sources counted:{" "}
                <strong>{totalSources}</strong>
              </div>
            </div>
            <table className="summary-table">
              <thead>
                <tr>
                  <th>Turn</th>
                  <th>Cards seen</th>
                  <th>Need ≥</th>
                  <th>P(hit)</th>
                </tr>
              </thead>
              <tbody>
                {rows.map((r) => (
                  <tr key={r.turn}>
                    <td>{r.turn}</td>
                    <td>{r.cardsSeen}</td>
                    <td>{r.need}</td>
                    <td>{pct(r.p)}</td>
                  </tr>
                ))}
              </tbody>
            </table>
            <div className="muted" style={{ marginTop: 4 }}>
              Each ramp spell’s “Virtual land” field contributes to the total
              sources. This doesn’t change when you draw them – they’re baked
              directly into the odds you’re tuning against.
            </div>
          </div>
        );
      }

      function ColorsTab({ stats }) {
        const colors = ["W", "U", "B", "R", "G", "C"];
        const labels = {
          W: "White",
          U: "Blue",
          B: "Black",
          R: "Red",
          G: "Green",
          C: "Colorless"
        };
        const totalPips = colors.reduce(
          (sum, c) => sum + (stats.pipTotals[c] || 0),
          0
        );

        if (!totalPips) {
          return (
            <div className="muted">
              Color pips will appear once cards with mana costs are loaded.
            </div>
          );
        }

        return (
          <div>
            <table className="summary-table">
              <thead>
                <tr>
                  <th>Color</th>
                  <th>Pips in spells</th>
                  <th>Sources on lands</th>
                  <th>Spell %</th>
                </tr>
              </thead>
              <tbody>
                {colors.map((c) => {
                  const pipCount = stats.pipTotals[c] || 0;
                  const landSources = stats.landSources[c] || 0;
                  if (!pipCount && !landSources) return null;
                  const spellPct =
                    totalPips > 0
                      ? ((pipCount / totalPips) * 100).toFixed(1)
                      : "0.0";
                  return (
                    <tr key={c}>
                      <td>
                        <span className={"pip pip-" + c}>{c}</span>&nbsp;
                        {labels[c]}
                      </td>
                      <td>{pipCount}</td>
                      <td>{landSources}</td>
                      <td>{spellPct}%</td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
            <div className="muted" style={{ marginTop: 4 }}>
              Rule of thumb: sources for each color should roughly track its
              share of pips across the deck. Outliers are where you’ll usually
              smooth first.
            </div>
          </div>
        );
      }

      function CurveTab({ stats }) {
        const buckets = [];
        for (let mv = 0; mv <= 10; mv++) {
          const count = stats.cmcCounts[mv] || 0;
          const weighted = stats.cmcWeights[mv] || 0;
          const anchor = stats.anchor ? stats.anchor[mv] || 0 : 0;
          if (!count && !anchor && !weighted) continue;
          buckets.push({ mv, count, weighted, anchor });
        }

        if (!buckets.length) {
          return (
            <div className="muted">
              Curve view needs spells with non-zero counts.
            </div>
          );
        }

        const maxActual = Math.max(...buckets.map((b) => b.count));
        const maxAnchor = Math.max(...buckets.map((b) => b.anchor));
        const max = Math.max(maxActual, maxAnchor, 1);

        return (
          <div>
            {stats.anchor ? (
              <div className="muted" style={{ marginBottom: 4 }}>
                Anchor curve is derived from deck size, land count and format
                bucket. Bars show actual vs. plan-weighted counts.
              </div>
            ) : (
              <div className="muted" style={{ marginBottom: 4 }}>
                No anchor curve available – size isn’t close to 40, 60 or 99
                with a recognised land count.
              </div>
            )}
            {buckets.map((b) => {
              const actualWidth = (b.count / max) * 100;
              const anchorWidth = (b.anchor / max) * 100;
              return (
                <div key={b.mv} className="curve-bar-row">
                  <div className="curve-bar-label">MV {b.mv}</div>
                  <div className="curve-bar-track">
                    <div
                      className="curve-bar-actual"
                      style={{ width: actualWidth + "%" }}
                    />
                    {anchorWidth > 0 && (
                      <div
                        className="curve-bar-anchor"
                        style={{ width: anchorWidth + "%" }}
                      />
                    )}
                  </div>
                  <div className="curve-bar-counts">
                    {b.count} / {b.anchor || "–"}
                  </div>
                </div>
              );
            })}
          </div>
        );
      }

      function HandSummaryTab({
        handState,
        handStats,
        mulliganStyle,
        setMulliganStyle,
        resetLibraryAndHand,
        mulliganHand,
        keepHand,
        resetHandLab,
        drawCard,
        nextCopyProbFor,
        tagCardZone
      }) {
        const hasDeck =
          handState.library.length ||
          handState.hand.length ||
          handState.samples;

        return (
          <div>
            <div className="row" style={{ marginBottom: 6 }}>
              <button onClick={resetLibraryAndHand}>New 7</button>
              <button
                className="secondary"
                onClick={mulliganHand}
                disabled={!handState.library.length && !handState.hand.length}
              >
                Mulligan
              </button>
              <button
                className="secondary"
                onClick={keepHand}
                disabled={!handState.hand.length}
              >
                Mark keep
              </button>
              <button
                className="secondary"
                onClick={drawCard}
                disabled={!handState.library.length && !handState.bottom.length}
              >
                Draw
              </button>
              <button
                className="secondary"
                onClick={resetHandLab}
                style={{ marginLeft: "auto" }}
              >
                Clear
              </button>
            </div>

            <div className="row" style={{ marginBottom: 6 }}>
              <label>
                Mulligan style:&nbsp;
                <select
                  value={mulliganStyle}
                  onChange={(e) => setMulliganStyle(e.target.value)}
                >
                  <option value="london">London (draw 7, bot N)</option>
                  <option value="vancouver">Vancouver (approximate)</option>
                  <option value="none">No mulligan math</option>
                </select>
              </label>
              {handStats && (
                <span className="chip">
                  Keep rate: {pct(handStats.keepRate || 0)} (
                  {handState.keeps}/{handState.samples})
                </span>
              )}
            </div>

            {!hasDeck && (
              <div className="muted">
                Hand Lab shuffles your list and lets you walk through draws
                without trying to fully emulate a board state. Generate a new
                hand to begin.
              </div>
            )}

            {hasDeck && (
              <div>
                <div className="handlab-container">
                  <div className="panel-inset">
                    <div
                      className="muted"
                      style={{ marginBottom: 3, fontSize: "0.75rem" }}
                    >
                      Hand ({handState.hand.length}) – change the zone select to
                      push a card to top, bottom, exile or graveyard. Hover a
                      card to see the chance the next draw is another copy.
                    </div>
                    <div>
                      {handState.hand.length === 0 && (
                        <div className="muted">
                          No cards in hand – draw or generate a new hand.
                        </div>
                      )}
                      {handState.hand.map((c) => (
                        <HandCardPill
                          key={c.id}
                          card={c}
                          nextCopyProbFor={nextCopyProbFor}
                          onZoneChange={tagCardZone}
                        />
                      ))}
                    </div>
                  </div>

                  <div className="panel-inset">
                    <div
                      className="muted"
                      style={{ marginBottom: 3, fontSize: "0.75rem" }}
                    >
                      Library: {handState.library.length} top /{" "}
                      {handState.bottom.length} bottom • Exile:{" "}
                      {handState.exile.length} • GY:{" "}
                      {handState.graveyard.length}
                    </div>
                    <div style={{ fontSize: "0.72rem" }}>
                      Cards placed on <strong>top</strong> will be drawn first;
                      cards placed on <strong>bottom</strong> will only be seen
                      after the rest of the library is exhausted. The “next copy
                      on draw” odds respect how many copies you’ve already seen.
                    </div>
                  </div>
                </div>
              </div>
            )}
          </div>
        );
      }

      function HandCardPill({ card, onZoneChange, nextCopyProbFor }) {
        const [hover, setHover] = useState(false);
        const pNext = nextCopyProbFor(card.name);

        return (
          <div
            className="hand-card-pill"
            onMouseEnter={() => setHover(true)}
            onMouseLeave={() => setHover(false)}
          >
            <span style={{ flex: 1 }}>{card.name}</span>
            <select
              style={{ fontSize: "0.65rem" }}
              onChange={(e) => onZoneChange(card.id, e.target.value)}
              defaultValue="hand"
            >
              <option value="hand">Hand</option>
              <option value="library-top">Top</option>
              <option value="library-bottom">Bottom</option>
              <option value="exile">Exile</option>
              <option value="graveyard">Graveyard</option>
            </select>
            {hover && (
              <span
                className="muted"
                style={{
                  marginLeft: 4,
                  fontSize: "0.65rem",
                  whiteSpace: "nowrap"
                }}
              >
                Next copy on draw: {pct(pNext)}
              </span>
            )}
          </div>
        );
      }

      /* --------------------------- mount React root --------------------------- */

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
