<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>CoAST – Calculator of All Structural Tuning</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root {
    --bg: #020617;
    --bg-panel: #020617;
    --accent: #38bdf8;
    --accent2: #22c55e;
    --accent3: #f97316;
    --border: #1f2937;
    --text: #e5e7ff;
    --muted: #9ca3c7;
    --danger: #f97373;
    --radius: 12px;
    --curve-0: #ec4899;
    --curve-1: #a855f7;
    --curve-2: #22c55e;
    --curve-3: #eab308;
    --curve-4: #f97316;
    --curve-5: #f97373;
  }

  body.theme-dark {
    --bg: #020617;
    --bg-panel: #020617;
    --border: #1f2937;
    --text: #e5e7ff;
    --muted: #9ca3c7;
  }
  body.theme-light {
    --bg: #f3f4f6;
    --bg-panel: #ffffff;
    --border: #d1d5db;
    --text: #020617;
    --muted: #6b7280;
  }
  body.theme-neon {
    --bg: #020617;
    --bg-panel: #020617;
    --border: #1e293b;
    --text: #e5e7ff;
    --muted: #9ca3c7;
  }

  * { box-sizing: border-box; }

  body {
    margin: 0;
    padding: 0;
    background: radial-gradient(circle at top left, #0f172a 0, var(--bg) 40%, #000814 100%);
    color: var(--text);
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    font-size: 15px;
  }

  .shell {
    max-width: 1200px;
    margin: 0 auto;
    padding: 12px;
  }

  h1, h2, h3 {
    margin: 0 0 0.4em;
    letter-spacing: 0.04em;
  }

  h1 {
    font-size: 1.7rem;
    display: flex;
    flex-wrap: wrap;
    align-items: baseline;
    gap: 8px;
  }

  .logo-coast {
    font-weight: 800;
    letter-spacing: 0.18em;
  }

  .pill {
    font-size: 0.7rem;
    padding: 3px 8px;
    border-radius: 999px;
    border: 1px solid rgba(56,189,248,0.35);
    color: var(--accent);
    background: rgba(15,23,42,0.9);
  }

  .muted {
    color: var(--muted);
    font-size: 0.85rem;
  }

  button {
    border-radius: 999px;
    border: none;
    padding: 7px 16px;
    font-size: 0.82rem;
    font-weight: 600;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 6px;
    background: linear-gradient(135deg, #22c55e, #38bdf8);
    color: white;
    box-shadow: 0 10px 22px rgba(56,189,248,0.4);
  }
  button.secondary {
    background: transparent;
    border: 1px solid var(--border);
    color: var(--muted);
    box-shadow: none;
  }
  button.danger {
    background: linear-gradient(135deg, #f97373, #fb7185);
    box-shadow: 0 10px 22px rgba(248,113,113,0.4);
  }
  button:disabled {
    opacity: 0.5;
    cursor: default;
    box-shadow: none;
  }

  input[type="text"],
  input[type="number"],
  select,
  textarea {
    background: #020617;
    color: var(--text);
    border-radius: 999px;
    border: 1px solid var(--border);
    padding: 6px 10px;
    font-size: 0.85rem;
    font-family: inherit;
    box-shadow: inset 0 0 0 1px #000, inset 0 6px 12px rgba(0,0,0,0.7);
  }
  body.theme-light input[type="text"],
  body.theme-light input[type="number"],
  body.theme-light select,
  body.theme-light textarea {
    background: #f9fafb;
    color: #020617;
    box-shadow: none;
  }

  textarea {
    border-radius: 10px;
    resize: vertical;
  }

  label {
    font-size: 0.8rem;
    color: var(--muted);
  }

  .card {
    background: radial-gradient(circle at top left, #0b1220 0, var(--bg-panel) 55%);
    border-radius: var(--radius);
    border: 1px solid var(--border);
    padding: 12px;
    box-shadow: 0 14px 32px rgba(0,0,0,0.55);
  }

  .panel-inset {
    border-radius: var(--radius);
    background: var(--bg-panel);
    border: 1px solid var(--bg-panel);
    box-shadow: inset 0 0 0 1px #111827, inset 0 8px 16px rgba(0,0,0,0.7);
    padding: 8px;
  }

  .panel-raised {
    border-radius: var(--radius);
    background: radial-gradient(circle at top left, var(--bg-panel) 0, var(--bg-panel) 55%);
    border: 1px solid #111827;
    box-shadow: 0 12px 26px rgba(15,23,42,0.9);
    padding: 8px;
  }

  .start-screen {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-top: 10px;
  }

  .start-options {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
  }

  .topbar {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
    margin-bottom: 8px;
  }

  .topbar-right {
    margin-left: auto;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
  }

  .theme-toggle {
    display: inline-flex;
    gap: 4px;
    padding: 2px;
    border-radius: 999px;
    border: 1px solid var(--border);
    background: rgba(15,23,42,0.9);
  }
  .theme-pill {
    border-radius: 999px;
    padding: 2px 8px;
    font-size: 0.7rem;
    cursor: pointer;
    color: var(--muted);
  }
  .theme-pill.active {
    background: linear-gradient(135deg, #22c55e, #38bdf8);
    color: white;
  }

  .chip {
    font-size: 0.75rem;
    padding: 3px 8px;
    border-radius: 999px;
    border: 1px solid var(--border);
    color: var(--muted);
    background: rgba(15,23,42,0.9);
  }
  .chip.bad { border-color: var(--danger); color: var(--danger); }
  .chip.warn { border-color: #facc15; color: #facc15; }
  .chip.ok { border-color: var(--accent2); color: var(--accent2); }

  .row {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
    margin-bottom: 4px;
  }

  .deck-layout {
    display: grid;
    grid-template-columns: minmax(0, 1.2fr) minmax(0, 0.8fr);
    gap: 12px;
  }

  .deck-toolbar {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    align-items: center;
    justify-content: space-between;
    margin: 6px 0;
  }

  .deck-container {
    background: rgba(15,23,42,0.9);
    border-radius: 9px;
    border: 1px solid var(--border);
    max-height: 340px;
    overflow: auto;
    padding: 6px;
  }

  .deck-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: 6px;
  }

  .deck-card {
    background: #020617;
    border-radius: 10px;
    border: 1px solid #111827;
    padding: 4px 4px 6px;
    display: flex;
    flex-direction: column;
    gap: 4px;
    font-size: 0.8rem;
    overflow: hidden;
  }

  body.theme-light .deck-card { background: #f9fafb; border-color: #d1d5db; }

  .deck-card img {
    width: 100%;
    border-radius: 8px;
    display: block;
  }

  .deck-card-header {
    display: flex;
    justify-content: space-between;
    gap: 4px;
    align-items: center;
    margin-top: 4px;
  }

  .qty-pill {
    font-size: 0.7rem;
    padding: 2px 5px;
    border-radius: 999px;
    border: 1px solid #1f2937;
    background: rgba(15,23,42,0.9);
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }

  .qty-btn {
    width: 16px;
    height: 16px;
    border-radius: 999px;
    border: none;
    background: #0f172a;
    color: #e5e7eb;
    font-size: 0.7rem;
    cursor: pointer;
    display: inline-flex;
    justify-content: center;
    align-items: center;
  }

  .pip-row {
    display: flex;
    gap: 3px;
    align-items: center;
    flex-wrap: wrap;
  }
  .pip {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 0.7rem;
    border: 1px solid #0f172a;
  }
  .pip-W { background: #f9fafb; color: #111827; }
  .pip-U { background: #0ea5e9; color: #0b1120; }
  .pip-B { background: #111827; color: #e5e7eb; }
  .pip-R { background: #ef4444; color: #111827; }
  .pip-G { background: #16a34a; color: #022c22; }
  .pip-C { background: #9ca3af; color: #111827; }

  .deck-list-row {
    display: grid;
    grid-template-columns: 50px minmax(0, 1.4fr) minmax(0, 1.1fr) 80px 70px;
    gap: 4px;
    padding: 3px 4px;
    font-size: 0.8rem;
    align-items: center;
    border-radius: 6px;
  }
  .deck-list-row:nth-child(odd) {
    background: rgba(15,23,42,0.9);
  }

  .summary-panel {
    background: rgba(15,23,42,0.95);
    border-radius: 10px;
    border: 1px solid var(--border);
    padding: 8px;
    max-height: 260px;
    overflow: auto;
    font-size: 0.8rem;
  }
  body.theme-light .summary-panel {
    background: #ffffff;
  }

  .summary-section { margin-bottom: 8px; }
  .summary-title { font-size: 0.9rem; font-weight: 600; margin-bottom: 4px; }

  .summary-grid {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }

  .summary-chip {
    padding: 4px 8px;
    border-radius: 999px;
    border: 1px solid var(--border);
    background: rgba(15,23,42,0.9);
    font-size: 0.75rem;
  }

  .summary-tabs {
    display: flex;
    gap: 6px;
    margin: 4px 0 6px;
    overflow-x: auto;
  }
  .summary-tab-btn {
    border-radius: 999px;
    border: 1px solid var(--border);
    background: rgba(15,23,42,0.9);
    color: var(--muted);
    font-size: 0.75rem;
    padding: 4px 10px;
    cursor: pointer;
    flex-shrink: 0;
  }
  .summary-tab-btn.active {
    border-color: var(--accent);
    color: var(--accent);
    box-shadow: 0 0 0 1px rgba(56,189,248,0.6);
  }

  .summary-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.75rem;
  }
  .summary-table th,
  .summary-table td {
    border-bottom: 1px solid rgba(15,23,42,0.8);
    padding: 3px 4px;
    text-align: right;
    white-space: nowrap;
  }
  .summary-table th:first-child,
  .summary-table td:first-child {
    text-align: left;
  }
  .summary-table tr:last-child th,
  .summary-table tr:last-child td {
    border-bottom: none;
  }

  .plan-card { margin-top: 8px; }
  .plan-tabs {
    display: flex;
    gap: 6px;
    margin-bottom: 6px;
    overflow-x: auto;
  }
  .plan-tab-btn {
    border-radius: 999px;
    border: 1px solid var(--border);
    background: rgba(15,23,42,0.9);
    color: var(--muted);
    font-size: 0.75rem;
    padding: 3px 10px;
    cursor: pointer;
    flex-shrink: 0;
  }
  .plan-tab-btn.active {
    border-color: var(--accent);
    color: var(--accent);
    box-shadow: 0 0 0 1px rgba(56,189,248,0.6);
  }

  .plan-hand {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
    gap: 4px;
    margin-top: 4px;
  }
  .plan-hand-card {
    border-radius: 8px;
    border: 1px solid #111827;
    background: #020617;
    padding: 3px 5px;
    font-size: 0.72rem;
  }

  .modal-backdrop {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.65);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 20;
    overflow-y: auto;
    padding: 24px 8px;
  }

  .modal {
    background: radial-gradient(circle at top left, #0b1220 0, #020617 65%);
    border-radius: 12px;
    border: 1px solid var(--border);
    padding: 12px;
    max-width: 480px;
    width: 100%;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: 0 18px 40px rgba(0,0,0,0.8);
  }
  body.theme-light .modal {
    background: #ffffff;
  }

  .modal-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 6px;
  }

  .modal-body {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-top: 8px;
  }

  .modal-img-wrap { width: 100%; text-align: center; }
  .modal-img-wrap img {
    max-width: 100%;
    border-radius: 10px;
    border: 1px solid #111827;
  }

  .field-group {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    align-items: center;
  }
  .field-group > * { flex: 1 1 120px; }

  .error {
    color: var(--danger);
    font-size: 0.8rem;
    margin-top: 4px;
  }

  .tiny-label { font-size: 0.7rem; color: var(--muted); }

  /* Curve graph */
  .curve-graph-wrap {
    width: 100%;
    height: 160px;
    margin: 4px 0;
    position: relative;
  }
  .curve-tooltip {
    position: absolute;
    min-width: 160px;
    max-width: 260px;
    background: rgba(15,23,42,0.98);
    border-radius: 8px;
    border: 1px solid var(--border);
    padding: 6px;
    font-size: 0.75rem;
    color: var(--text);
    pointer-events: none;
    display: none;
    z-index: 5;
  }

  /* Toast */
  #toast {
    position: fixed;
    bottom: 12px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(15,23,42,0.98);
    color: var(--text);
    padding: 8px 14px;
    border-radius: 999px;
    border: 1px solid var(--border);
    font-size: 0.8rem;
    box-shadow: 0 10px 26px rgba(0,0,0,0.8);
    z-index: 50;
    display: none;
  }

  /* My decks modal */
  #decksModalBackdrop {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.65);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 25;
  }
  #decksModal {
    background: radial-gradient(circle at top left, #0b1220 0, #020617 65%);
    border-radius: 12px;
    border: 1px solid var(--border);
    padding: 12px;
    max-width: 520px;
    width: calc(100% - 24px);
    max-height: 80vh;
    overflow-y: auto;
  }

  @media (max-width: 960px) {
    .deck-layout { grid-template-columns: 1fr; }
  }
  @media (max-width: 700px) {
    .shell { padding: 8px; }
    body { font-size: 16px; }
    h1 { font-size: 1.4rem; flex-direction: column; align-items: flex-start; }
    .deck-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    .deck-container { max-height: none; }
    .summary-panel { max-height: none; }
    .modal { max-width: 100%; }
  }
</style>
</head>
<body class="theme-dark">
<div class="shell">
  <div id="toast"></div>

  <h1>
    <span class="logo-coast">CoAST</span>
    <span class="pill">Calculator of All Structural Tuning</span>
    <div class="theme-toggle" id="themeToggle">
      <div class="theme-pill active" data-theme="dark">Dark</div>
      <div class="theme-pill" data-theme="light">Light</div>
      <div class="theme-pill" data-theme="neon">Neon</div>
    </div>
  </h1>
  <p class="muted">
    A deck-building sandbar: curve hills, land odds, colour sources, and plans tuned together so your mana feels as good as your spells.
  </p>

  <!-- START SCREEN -->
  <div id="startScreen" class="card start-screen panel-raised">
    <h2>Where are we sailing?</h2>
    <div class="start-options">
      <button id="btnBuild">Build a deck</button>
      <button id="btnImport">Import a deck</button>
      <button class="secondary" id="btnLandCalc">Land odds only</button>
    </div>
    <p class="muted">
      • <b>Build</b>: search cards, tweak quantities, tag ramp/cantrips/plans, &amp; see structure update live.<br/>
      • <b>Import</b>: paste a list and let CoAST read its bones.<br/>
      • <b>Land odds</b>: quick hypergeometric land calculator without a decklist.
    </p>
  </div>

  <!-- MAIN APP -->
  <div id="deckApp" style="display:none; margin-top:8px;">
    <div class="topbar">
      <button class="secondary" id="backToHome">← Home</button>
      <div>
        <label>Deck name</label><br/>
        <input type="text" id="deckName" placeholder="Untitled deck" />
      </div>
      <div>
        <label>Format</label><br/>
        <select id="deckFormat">
          <option value="auto">Auto (from size)</option>
          <option value="limited">Limited (40)</option>
          <option value="constructed">Constructed (60)</option>
          <option value="commander">Commander (99/100)</option>
          <option value="custom">Custom</option>
        </select>
      </div>
      <div>
        <label>Target size</label><br/>
        <input type="number" id="deckSizeInput" min="1" step="1" value="60" />
      </div>
      <div>
        <label>Land count</label><br/>
        <input type="number" id="landCountInput" min="0" step="1" value="24" />
      </div>
      <div class="topbar-right">
        <span id="deckStatusChip" class="chip">No cards yet</span>
        <button class="secondary" id="saveDeckBtn">Save</button>
        <button class="secondary" id="openDecksBtn">My decks</button>
      </div>
    </div>

    <div class="deck-layout">
      <!-- LEFT -->
      <div class="card panel-inset">
        <h2 id="builderTitle">Deck builder</h2>

        <div class="row">
          <div>
            <label>Mode</label><br/>
            <select id="builderMode">
              <option value="build">Build with search</option>
              <option value="import">Paste &amp; edit list</option>
            </select>
          </div>
          <div>
            <label>Main / Sideboard</label><br/>
            <select id="mainSideMode">
              <option value="main">Main deck</option>
              <option value="side">Sideboard</option>
            </select>
          </div>
          <div id="cardCountSummary" class="muted"></div>
        </div>

        <div id="buildControls" class="panel-inset" style="margin-bottom:4px;">
          <div class="field-group">
            <div style="flex: 2;">
              <label>Add card (Scryfall)</label><br/>
              <input type="text" id="cardSearchName" placeholder="Lightning Bolt" />
            </div>
            <div>
              <label>Qty</label><br/>
              <input type="number" id="cardSearchQty" min="1" step="1" value="1" />
            </div>
            <div>
              <label>&nbsp;</label><br/>
              <button class="secondary" id="addCardBtn">Add</button>
            </div>
          </div>
          <p class="muted">
            Type a card name &amp; press Enter. Click a card tile or row to open its detail panel.
          </p>
        </div>

        <div id="importControls" class="panel-inset" style="display:none; margin-top:4px;">
          <label>Decklist text (main deck only)</label><br/>
          <textarea id="deckText" rows="8" spellcheck="false"
            placeholder="4 Lightning Bolt&#10;4 Monastery Swiftspear&#10;2 Searing Blaze&#10;20 Mountain"></textarea>
          <p class="muted">
            Formats like <code>4 Lightning Bolt</code> or <code>4 Lightning Bolt (2XM) 123</code>. Lines starting
            with <code>//</code> or <code>#</code> are ignored. Sideboard is managed from the builder.
          </p>
        </div>

        <div class="deck-toolbar">
          <div>
            <label>View</label>
            <select id="viewMode">
              <option value="grid">Grid (images)</option>
              <option value="list">List</option>
            </select>
            &nbsp;&nbsp;
            <label>Group</label>
            <select id="groupMode">
              <option value="none">None</option>
              <option value="type">Type</option>
              <option value="mv">Mana value</option>
              <option value="color">Colour</option>
            </select>
          </div>
          <div>
            <span id="summaryBadge" class="chip">Main: 0 | Side: 0</span>
          </div>
        </div>

        <div id="deckContainer" class="deck-container">
          <div class="muted">No cards yet. Use the search above or paste a list.</div>
        </div>

        <div id="builderStatus" class="muted" style="margin-top:4px;"></div>
      </div>

      <!-- RIGHT -->
      <div class="card panel-raised">
        <h2>Summary &amp; Plans</h2>

        <div class="summary-tabs">
          <button class="summary-tab-btn active" data-summary-tab-btn="overview">Overview</button>
          <button class="summary-tab-btn" data-summary-tab-btn="curve">Curve</button>
          <button class="summary-tab-btn" data-summary-tab-btn="lands">Lands</button>
          <button class="summary-tab-btn" data-summary-tab-btn="virtual">Virtual lands</button>
          <button class="summary-tab-btn" data-summary-tab-btn="colors">Colours</button>
        </div>

        <div class="row" style="margin-bottom:4px;">
          <div>
            <label>Land odds view</label><br/>
            <select id="landViewMode">
              <option value="play">On the play</option>
              <option value="draw">On the draw</option>
            </select>
          </div>
        </div>

        <div id="summaryPanel" class="summary-panel">
          <div id="summaryOverview" data-summary-tab="overview">
            <div class="muted">(No analysis yet. Add cards or paste a deck.)</div>
          </div>
          <div id="summaryCurve" data-summary-tab="curve" style="display:none;">
            <div class="muted">(No analysis yet. Add cards or paste a deck.)</div>
          </div>
          <div id="summaryLands" data-summary-tab="lands" style="display:none;">
            <div class="muted">(No analysis yet. Add cards or paste a deck.)</div>
          </div>
          <div id="summaryVirtual" data-summary-tab="virtual" style="display:none;">
            <div class="muted">(No analysis yet. Add cards or paste a deck.)</div>
          </div>
          <div id="summaryColors" data-summary-tab="colors" style="display:none;">
            <div class="muted">(No analysis yet. Add cards or paste a deck.)</div>
          </div>
        </div>
        <div id="summaryError" class="error"></div>

        <div class="plan-card panel-raised">
          <div class="plan-tabs">
            <button class="plan-tab-btn active" data-plan="A">Plan A</button>
            <button class="plan-tab-btn" data-plan="B">Plan B</button>
            <button class="plan-tab-btn" data-plan="C">Plan C</button>
            <button class="plan-tab-btn" data-plan="D">Plan D</button>
            <button class="plan-tab-btn" data-plan="E">Plan E</button>
          </div>
          <div class="row">
            <div>
              <label>Target turn</label><br/>
              <input type="number" id="planTargetTurn" min="1" step="1" value="3" />
            </div>
            <div class="muted" id="planMeta"></div>
          </div>
          <div id="planContent" style="font-size:0.8rem;">
            <div class="muted">(Tag cards with Plan A–E in their detail panel to see plan summaries.)</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- LAND CALC APP -->
  <div id="landCalcApp" style="display:none; margin-top:8px;">
    <div class="topbar">
      <button class="secondary" id="backFromLand">← Home</button>
      <h2>Land odds calculator</h2>
    </div>
    <div class="deck-layout">
      <div class="card panel-inset">
        <h3>Inputs</h3>
        <div class="row">
          <div>
            <label>Deck size</label><br/>
            <input type="number" id="lcDeckSize" min="1" step="1" value="60" />
          </div>
          <div>
            <label>Land count</label><br/>
            <input type="number" id="lcLandCount" min="0" step="1" value="24" />
          </div>
        </div>
        <div class="row">
          <div>
            <label>Turns (max)</label><br/>
            <input type="number" id="lcMaxTurn" min="1" step="1" value="5" />
          </div>
          <div>
            <label>Play / draw</label><br/>
            <select id="lcPlayDraw">
              <option value="play">On the play</option>
              <option value="draw">On the draw (+1 card)</option>
            </select>
          </div>
        </div>
        <button id="lcCalcBtn">Calculate</button>
      </div>
      <div class="card panel-raised">
        <h3>Results</h3>
        <pre id="lcResults" style="white-space:pre-wrap; font-family:'Fira Code',monospace; font-size:11px;">
(No calculation yet.)</pre>
      </div>
    </div>
  </div>

  <!-- ABOUT -->
  <div id="aboutCard" class="card panel-raised" style="margin-top:10px;">
    <div class="row" style="justify-content:space-between;">
      <h2 style="margin-bottom:0;">About CoAST</h2>
      <button class="secondary" id="toggleAboutBtn">Show details</button>
    </div>
    <div id="aboutContent" class="muted" style="display:none; margin-top:8px; font-size:0.8rem;">
      <p><b>CoAST</b> (Calculator of All Structural Tuning) is a client-side tool for Magic: the Gathering that treats your deck like a system: lands, spells, ramp, cantrips, colour pips, and game plans are all analysed together.</p>
      <p>Core ideas:</p>
      <ul style="padding-left:18px;">
        <li>Use <b>curve hills</b> and <b>WPL (weight per land)</b> to understand how heavy your deck actually is.</li>
        <li>Use hypergeometric math to estimate <b>land consistency</b> with and without ramp (virtual lands).</li>
        <li>Use pip counts and colour sources to sanity check your mana base.</li>
        <li>Tag cards into <b>Plans A–E</b> and see how often your core plans actually come together by a target turn.</li>
      </ul>
      <p>All calculations run in your browser. No accounts, no servers, no paywalls. Card data and art are fetched from the public Scryfall API.</p>
    </div>
  </div>

  <!-- CARD PROFILE MODAL -->
  <div id="cardModalBackdrop" class="modal-backdrop">
    <div class="modal">
      <div class="modal-header">
        <div>
          <h3 id="modalCardName">Card</h3>
          <div class="muted" id="modalCardType"></div>
        </div>
        <button class="secondary" id="closeModalBtn">✕</button>
      </div>

      <div class="modal-body">
        <div class="modal-img-wrap">
          <img id="modalCardImg" alt="Card image" />
        </div>

        <div class="panel-inset">
          <div class="field-group">
            <div>
              <label>Zone</label><br/>
              <select id="modalZone">
                <option value="main">Main deck</option>
                <option value="side">Sideboard</option>
              </select>
            </div>
            <div>
              <label>Quantity</label><br/>
              <input type="number" id="modalQty" min="0" step="1" />
              <p class="muted">Set to 0 to remove from that zone.</p>
            </div>
          </div>

          <hr/>

          <div class="field-group">
            <div>
              <label>Effective mana value (override)</label><br/>
              <input type="number" id="modalEffMV" min="0" step="1" placeholder="Use printed MV" />
              <p class="muted">For things like “7-drop cast for 4”. Global curve uses this if set.</p>
            </div>
          </div>

          <hr/>

          <div>
            <label>Ramp profile (optional)</label>
            <div class="field-group" style="margin-top:4px;">
              <div>
                <label>Type</label><br/>
                <select id="modalRampType">
                  <option value="">None</option>
                  <option value="dork">Dork (creature)</option>
                  <option value="rock">Rock (artifact)</option>
                  <option value="land">Land tutor / ramp</option>
                  <option value="burst">Burst (ritual)</option>
                  <option value="cheat">Cheat (reanimate / sneak)</option>
                </select>
              </div>
              <div>
                <label>Online turn</label><br/>
                <input type="number" id="modalRampTurn" min="1" step="1" placeholder="2" />
              </div>
              <div>
                <label>Net mana</label><br/>
                <input type="number" id="modalRampNet" step="1" placeholder="+1" />
              </div>
            </div>
          </div>

          <hr/>

          <div>
            <label>Cantrip / selection (optional)</label>
            <div class="field-group" style="margin-top:4px;">
              <div>
                <label>Extra cards seen (avg)</label><br/>
                <input type="number" id="modalCantrip" min="0" step="0.1" placeholder="0.6" />
              </div>
            </div>
            <p class="muted">Rough guideline: scry / small peeks ~0.6, Impulse-style ~1.2–1.5.</p>
          </div>

          <hr/>

          <div>
            <label>Plan tags</label>
            <div style="display:flex;flex-wrap:wrap;gap:6px;margin-top:4px;">
              <label class="summary-chip"><input type="checkbox" id="modalPlanA" /> Plan A</label>
              <label class="summary-chip"><input type="checkbox" id="modalPlanB" /> Plan B</label>
              <label class="summary-chip"><input type="checkbox" id="modalPlanC" /> Plan C</label>
              <label class="summary-chip"><input type="checkbox" id="modalPlanD" /> Plan D</label>
              <label class="summary-chip"><input type="checkbox" id="modalPlanE" /> Plan E</label>
            </div>
          </div>

          <hr/>

          <div>
            <label>Plan-specific MV overrides</label>
            <div class="field-group" style="margin-top:4px;">
              <div><span class="tiny-label">Plan A</span><br/><input type="number" id="planEffA" min="0" step="1" placeholder="-" /></div>
              <div><span class="tiny-label">Plan B</span><br/><input type="number" id="planEffB" min="0" step="1" placeholder="-" /></div>
              <div><span class="tiny-label">Plan C</span><br/><input type="number" id="planEffC" min="0" step="1" placeholder="-" /></div>
              <div><span class="tiny-label">Plan D</span><br/><input type="number" id="planEffD" min="0" step="1" placeholder="-" /></div>
              <div><span class="tiny-label">Plan E</span><br/><input type="number" id="planEffE" min="0" step="1" placeholder="-" /></div>
            </div>
          </div>
        </div>

        <div style="margin-top:6px;" id="modalSummary" class="summary-chip" >
          (Per-card summary will appear here.)
        </div>

        <button id="modalSaveBtn" style="margin-top:6px;">Save card profile</button>
      </div>
    </div>
  </div>

  <!-- MY DECKS MODAL -->
  <div id="decksModalBackdrop">
    <div id="decksModal">
      <div class="row" style="justify-content:space-between;">
        <h3>My decks (local)</h3>
        <button class="secondary" id="closeDecksBtn">✕</button>
      </div>
      <div id="decksList" class="muted" style="margin-top:6px; font-size:0.8rem;">
        (No decks saved yet.)
      </div>
    </div>
  </div>

  <!-- Curve tooltip -->
  <div id="curveTooltip" class="curve-tooltip"></div>

</div>

<script>
// ----- combinatorics -----
function comb(n, k) {
  if (k < 0 || k > n) return 0;
  if (k === 0 || k === n) return 1;
  k = Math.min(k, n - k);
  let res = 1;
  for (let i = 1; i <= k; i++) res = res * (n - k + i) / i;
  return res;
}
function hyperPMF(k, K, N, n) {
  if (n > N) return 0;
  const num = comb(K, k) * comb(N - K, n - k);
  const den = comb(N, n);
  return den === 0 ? 0 : num / den;
}
function probAtLeast(k, K, N, n) {
  let p = 0;
  const maxK = Math.min(K, n);
  for (let i = k; i <= maxK; i++) p += hyperPMF(i, K, N, n);
  return p;
}
function pct(p) {
  if (!Number.isFinite(p)) return '0.0%';
  return (p * 100).toFixed(1) + '%';
}

// ----- toast -----
let toastTimer = null;
function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.style.display = 'block';
  clearTimeout(toastTimer);
  toastTimer = setTimeout(() => { t.style.display = 'none'; }, 2600);
}

// ----- Scryfall -----
const scryfallCache = new Map();
async function fetchCardData(name, mode = 'fuzzy') {
  const key = (mode + ':' + name).toLowerCase();
  if (scryfallCache.has(key)) return scryfallCache.get(key);
  let data;
  try {
    const param = mode === 'exact' ? 'exact' : 'fuzzy';
    const resp = await fetch(`https://api.scryfall.com/cards/named?${param}=${encodeURIComponent(name)}`);
    if (!resp.ok) throw new Error('Scryfall error');
    data = await resp.json();
  } catch {
    data = { name, cmc: 0, type_line: 'Unknown', color_identity: [], mana_cost: '' };
  }
  let image = null;
  if (data.image_uris && data.image_uris.normal) {
    image = data.image_uris.normal;
  } else if (Array.isArray(data.card_faces) && data.card_faces[0] &&
             data.card_faces[0].image_uris && data.card_faces[0].image_uris.normal) {
    image = data.card_faces[0].image_uris.normal;
  }
  data._coast_image = image;
  scryfallCache.set(key, data);
  return data;
}

// ----- state -----
const state = {
  mode: 'build',
  viewMode: 'grid',
  groupMode: 'none',
  landViewMode: 'play',
  deckEntries: {},      // main
  sideEntries: {},      // sideboard
  cardInfos: [],
  tuning: {},
  lastResult: null,
  mvToNames: {},
  activePlan: 'A',
  planSettings: { A:{targetTurn:3}, B:{targetTurn:3}, C:{targetTurn:3}, D:{targetTurn:3}, E:{targetTurn:3} },
  summaryTab: 'overview',
  theme: 'dark'
};

// simple anchors (can be expanded with your detailed heatmaps)
const ANCHOR_CURVES = {
  40: { 16: {1: 6, 2: 12, 3: 6} },
  60: { 24: {1: 10, 2: 14, 3: 7, 4: 5, 5: 3, 6: 1} },
  99: { 35: {1: 5, 2: 12, 3: 13, 4: 10, 5: 7, 6: 5, 7: 3, 8: 1} }
};

function getAnchor(sizeBucket, landCount) {
  const entry = ANCHOR_CURVES[sizeBucket];
  if (!entry) return null;
  if (entry[landCount]) return entry[landCount];
  const keys = Object.keys(entry).map(x => parseInt(x,10));
  if (!keys.length) return null;
  let nearest = keys[0];
  for (const k of keys) if (Math.abs(k - landCount) < Math.abs(nearest - landCount)) nearest = k;
  return entry[nearest];
}

function show(id){ document.getElementById(id).style.display = ''; }
function hide(id){ document.getElementById(id).style.display = 'none'; }

// ----- deck text parsing -----
function deckEntriesFromText(text) {
  const LINE_RE = /^\s*(\d+)[xX]?\s+(.+?)(?:\s+\([^)]+\)\s+\d+)?\s*$/;
  const lines = text.split(/\r?\n/);
  const entries = {};
  for (const raw of lines) {
    const line = raw.trim();
    if (!line || line.startsWith('#') || line.startsWith('//')) continue;
    const m = line.match(LINE_RE);
    if (!m) continue;
    const qty = parseInt(m[1], 10);
    const name = m[2].trim();
    if (!name || !Number.isFinite(qty)) continue;
    entries[name] = (entries[name] || 0) + qty;
  }
  return entries;
}
function deckEntriesToText(entries) {
  return Object.keys(entries)
    .sort((a,b)=>a.localeCompare(b))
    .map(name=>`${entries[name]} ${name}`)
    .join('\n');
}
function rebuildDeckTextFromState() {
  const textarea = document.getElementById('deckText');
  if (!textarea) return;
  textarea.value = deckEntriesToText(state.deckEntries);
}

// ----- theme -----
function setTheme(theme) {
  state.theme = theme;
  document.body.classList.remove('theme-dark','theme-light','theme-neon');
  document.body.classList.add(`theme-${theme}`);
  document.querySelectorAll('.theme-pill').forEach(p => {
    p.classList.toggle('active', p.dataset.theme === theme);
  });
}
document.getElementById('themeToggle').addEventListener('click', e => {
  const pill = e.target.closest('.theme-pill');
  if (!pill) return;
  setTheme(pill.dataset.theme);
});

// ----- analysis -----
async function analyzeDeck() {
  const summaryError = document.getElementById('summaryError');
  summaryError.textContent = '';
  const names = Object.keys(state.deckEntries);
  if (!names.length) {
    state.cardInfos = [];
    state.lastResult = null;
    state.mvToNames = {};
    renderDeckView();
    updateDeckStatusChip();
    renderSummary(null);
    renderPlanPanel();
    return;
  }

  const cardInfos = [];
  const mvToNames = {};
  for (const name of names) {
    const info = await fetchCardData(name, 'exact');
    const profile = state.tuning[info.name] || state.tuning[name] || {};
    const printedMV = Math.round(info.cmc || 0);
    const effMV = (profile.effMV !== undefined && profile.effMV !== null && !Number.isNaN(profile.effMV))
      ? Number(profile.effMV)
      : printedMV;
    const qty = state.deckEntries[name];

    const mvBucket = Math.max(0, Math.min(10, effMV));
    if (!mvToNames[mvBucket]) mvToNames[mvBucket] = [];
    mvToNames[mvBucket].push({ name: info.name || name, qty });

    cardInfos.push({
      name: info.name || name,
      key: info.name || name,
      qty,
      mv: effMV,
      printed_mv: printedMV,
      type_line: info.type_line || 'Unknown',
      colors: info.colors || [],
      color_identity: info.color_identity || [],
      mana_cost: info.mana_cost || '',
      image_url: info._coast_image || null
    });
  }
  state.cardInfos = cardInfos;
  state.mvToNames = mvToNames;

  const deckSize = cardInfos.reduce((a,c)=>a + c.qty, 0);
  const landInput = parseInt(document.getElementById('landCountInput').value,10);
  let landCount = Number.isFinite(landInput) ? landInput : 0;

  if (landCount === 0) {
    landCount = cardInfos.reduce((a,c)=>{
      if ((c.type_line || '').toLowerCase().includes('land')) return a + c.qty;
      return a;
    }, 0);
  }

  const nonlandCount = deckSize - landCount;
  const curve = {};
  for (let mv=0; mv<=10; mv++) curve[mv] = 0;
  let deckWeight = 0;

  for (const c of cardInfos) {
    const isLand = (c.type_line || '').toLowerCase().includes('land');
    if (!isLand) {
      const mv = Math.max(0, Math.min(10, c.mv));
      curve[mv] += c.qty;
      deckWeight += mv * c.qty;
    }
  }
  const wpl = landCount ? deckWeight / landCount : 0;

  // land tables for play/draw
  const landTablePlay = [];
  const landTableDraw = [];
  for (let turn=1; turn<=5; turn++) {
    let seenPlay = 7 + (turn - 1);
    let seenDraw = 7 + (turn - 1) + 1;
    if (seenPlay > deckSize) seenPlay = deckSize;
    if (seenDraw > deckSize) seenDraw = deckSize;
    landTablePlay.push({
      turn,
      seen: seenPlay,
      p1: probAtLeast(1, landCount, deckSize, seenPlay),
      p2: probAtLeast(2, landCount, deckSize, seenPlay),
      p3: probAtLeast(3, landCount, deckSize, seenPlay),
      p4: probAtLeast(4, landCount, deckSize, seenPlay)
    });
    landTableDraw.push({
      turn,
      seen: seenDraw,
      p1: probAtLeast(1, landCount, deckSize, seenDraw),
      p2: probAtLeast(2, landCount, deckSize, seenDraw),
      p3: probAtLeast(3, landCount, deckSize, seenDraw),
      p4: probAtLeast(4, landCount, deckSize, seenDraw)
    });
  }

  // ramp & cantrip coarse sums
  let totalRampCopies = 0;
  let totalCantripExtra = 0;
  for (const c of cardInfos) {
    const profile = state.tuning[c.name] || {};
    if (profile.rampType) totalRampCopies += c.qty;
    if (profile.cantripExtra) totalCantripExtra += profile.cantripExtra * c.qty;
  }
  const virtualLandCount = landCount + totalRampCopies;
  const landTablePlayVirtual = [];
  const landTableDrawVirtual = [];
  for (let turn=1; turn<=5; turn++) {
    let seenPlay = 7 + (turn - 1);
    let seenDraw = 7 + (turn - 1) + 1;
    if (seenPlay > deckSize) seenPlay = deckSize;
    if (seenDraw > deckSize) seenDraw = deckSize;
    landTablePlayVirtual.push({
      turn,
      seen: seenPlay,
      p1: probAtLeast(1, virtualLandCount, deckSize, seenPlay),
      p2: probAtLeast(2, virtualLandCount, deckSize, seenPlay),
      p3: probAtLeast(3, virtualLandCount, deckSize, seenPlay),
      p4: probAtLeast(4, virtualLandCount, deckSize, seenPlay)
    });
    landTableDrawVirtual.push({
      turn,
      seen: seenDraw,
      p1: probAtLeast(1, virtualLandCount, deckSize, seenDraw),
      p2: probAtLeast(2, virtualLandCount, deckSize, seenDraw),
      p3: probAtLeast(3, virtualLandCount, deckSize, seenDraw),
      p4: probAtLeast(4, virtualLandCount, deckSize, seenDraw)
    });
  }

  // pip vs sources
  const pipTotals = {};
  const pipRegex = /\{([WUBRG])\}/g;
  for (const c of cardInfos) {
    let m;
    const cost = c.mana_cost || '';
    while ((m = pipRegex.exec(cost)) !== null) {
      pipTotals[m[1]] = (pipTotals[m[1]] || 0) + c.qty;
    }
  }
  const landSources = {};
  for (const c of cardInfos) {
    const isLand = (c.type_line || '').toLowerCase().includes('land');
    if (!isLand) continue;
    for (const col of (c.color_identity || [])) {
      landSources[col] = (landSources[col] || 0) + c.qty;
    }
  }
  const neededSources = {};
  const deltaSources = {};
  const colSet = new Set([...Object.keys(pipTotals), ...Object.keys(landSources)]);
  for (const col of colSet) {
    const pips = pipTotals[col] || 0;
    const need = Math.ceil(pips / 3);
    neededSources[col] = need;
    const have = landSources[col] || 0;
    deltaSources[col] = have - need;
  }

  // anchors
  const formatSel = document.getElementById('deckFormat').value;
  let sizeBucket;
  if (formatSel === 'limited') sizeBucket = 40;
  else if (formatSel === 'constructed') sizeBucket = 60;
  else if (formatSel === 'commander') sizeBucket = 99;
  else {
    if (deckSize >= 35 && deckSize <= 50) sizeBucket = 40;
    else if (deckSize >= 51 && deckSize <= 75) sizeBucket = 60;
    else if (deckSize >= 90 && deckSize <= 110) sizeBucket = 99;
    else sizeBucket = null;
  }
  const anchor = sizeBucket ? getAnchor(sizeBucket, landCount) : null;
  let anchorInfo = null;
  if (anchor) {
    const anchorNonlands = Object.values(anchor).reduce((a,b)=>a+b,0);
    const scale = anchorNonlands ? (nonlandCount / anchorNonlands) : 1;
    const scaled = {};
    for (const [mv, qty] of Object.entries(anchor)) scaled[mv] = Math.round(qty * scale);
    anchorInfo = { raw: anchor, scaled };
  }

  const result = {
    deckName: document.getElementById('deckName').value || 'Untitled deck',
    deckSize,
    landCount,
    nonlandCount,
    deckWeight,
    wpl,
    curve,
    landTablePlay,
    landTableDraw,
    landTablePlayVirtual,
    landTableDrawVirtual,
    pipTotals,
    landSources,
    neededSources,
    deltaSources,
    anchorInfo,
    totalRampCopies,
    totalCantripExtra
  };
  state.lastResult = result;
  renderDeckView();
  updateDeckStatusChip(result);
  renderSummary(result);
  renderPlanPanel();
}

// ----- summary rendering -----
function setSummaryTab(tab) {
  state.summaryTab = tab;
  document.querySelectorAll('[data-summary-tab]').forEach(p=>{
    p.style.display = (p.getAttribute('data-summary-tab') === tab) ? '' : 'none';
  });
  document.querySelectorAll('[data-summary-tab-btn]').forEach(b=>{
    b.classList.toggle('active', b.getAttribute('data-summary-tab-btn') === tab);
  });
}

function renderSummary(r) {
  const elOverview = document.getElementById('summaryOverview');
  const elCurve = document.getElementById('summaryCurve');
  const elLands = document.getElementById('summaryLands');
  const elVirtual = document.getElementById('summaryVirtual');
  const elColors = document.getElementById('summaryColors');

  if (!r) {
    const msg = '<div class="muted">(No analysis yet. Add cards or paste a deck.)</div>';
    elOverview.innerHTML = msg;
    elCurve.innerHTML = msg;
    elLands.innerHTML = msg;
    elVirtual.innerHTML = msg;
    elColors.innerHTML = msg;
    setSummaryTab(state.summaryTab || 'overview');
    return;
  }

  const wplClass =
    r.wpl < 2.4 ? 'bad' :
    r.wpl <= 3.6 ? 'ok' : 'warn';

  const landClass =
    r.landCount <= 0 ? 'warn' :
    'ok';

  // Overview
  let htmlOverview = '';
  htmlOverview += '<div class="summary-section">';
  htmlOverview += '<div class="summary-title">Deck snapshot</div>';
  htmlOverview += '<div class="summary-grid">';
  htmlOverview += `<span class="summary-chip"><b>${r.deckName}</b></span>`;
  htmlOverview += `<span class="summary-chip ${landClass}">Size: ${r.deckSize} (lands ${r.landCount}, nonlands ${r.nonlandCount})</span>`;
  htmlOverview += `<span class="summary-chip ${wplClass}">WPL: ${r.wpl.toFixed(3)}</span>`;
  htmlOverview += `<span class="summary-chip">Ramp copies tagged: ${r.totalRampCopies}</span>`;
  htmlOverview += `<span class="summary-chip">Cantrip extra cards (sum): ${r.totalCantripExtra.toFixed(1)}</span>`;
  htmlOverview += '</div></div>';
  elOverview.innerHTML = htmlOverview;

  // Curve (graph + table)
  let htmlCurve = '';
  htmlCurve += '<div class="summary-section">';
  htmlCurve += '<div class="summary-title">Curve vs anchor hill</div>';
  htmlCurve += '<p class="muted">Hover a bar to see which cards sit at that mana value. MV 0 will reveal any “ghost 0-drops”.</p>';
  htmlCurve += '<div class="curve-graph-wrap"><svg id="curveSvg" width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none"></svg></div>';

  htmlCurve += '<table class="summary-table"><thead><tr><th>MV</th><th>In deck</th><th>Anchor*</th><th>Δ</th></tr></thead><tbody>';
  if (r.anchorInfo) {
    for (let mv=0; mv<=10; mv++) {
      const dq = r.curve[mv] || 0;
      const aq = r.anchorInfo.scaled[mv] || 0;
      if (!dq && !aq) continue;
      const diff = dq - aq;
      htmlCurve += `<tr data-mv-row="${mv}"><td>${mv}</td><td>${dq}</td><td>${aq}</td><td>${diff>=0?'+':''}${diff}</td></tr>`;
    }
  } else {
    for (let mv=0; mv<=10; mv++) {
      const dq = r.curve[mv] || 0;
      if (!dq) continue;
      htmlCurve += `<tr data-mv-row="${mv}"><td>${mv}</td><td>${dq}</td><td>–</td><td>–</td></tr>`;
    }
  }
  htmlCurve += '</tbody></table>';
  if (r.anchorInfo) {
    htmlCurve += '<p class="muted" style="margin-top:4px;">*Anchor scaled to match your total non-land count.</p>';
  }
  htmlCurve += '</div>';
  elCurve.innerHTML = htmlCurve;
  drawCurveGraph(r);

  // Lands
  const landView = state.landViewMode === 'draw' ? 'draw' : 'play';
  const table = landView === 'play' ? r.landTablePlay : r.landTableDraw;

  let htmlLands = '';
  htmlLands += '<div class="summary-section">';
  htmlLands += `<div class="summary-title">Land availability (${landView === 'play' ? 'on the play' : 'on the draw'})</div>`;
  htmlLands += '<table class="summary-table"><thead><tr><th>Turn</th><th>Cards seen</th><th>P(≥1 land)</th><th>P(≥2)</th><th>P(≥3)</th><th>P(≥4)</th></tr></thead><tbody>';
  for (const row of table) {
    htmlLands += `<tr><td>${row.turn}</td><td>${row.seen}</td><td>${pct(row.p1)}</td><td>${pct(row.p2)}</td><td>${pct(row.p3)}</td><td>${pct(row.p4)}</td></tr>`;
  }
  htmlLands += '</tbody></table></div>';
  elLands.innerHTML = htmlLands;

  // Virtual lands
  const vtable = landView === 'play' ? r.landTablePlayVirtual : r.landTableDrawVirtual;
  let htmlVirtual = '';
  htmlVirtual += '<div class="summary-section">';
  htmlVirtual += '<div class="summary-title">Virtual lands (ramp included – coarse)</div>';
  htmlVirtual += '<p class="muted">Each tagged ramp card currently counts as +1 virtual land source.</p>';
  htmlVirtual += '<table class="summary-table"><thead><tr><th>Turn</th><th>Cards seen</th><th>P(≥1 land)</th><th>P(≥2)</th><th>P(≥3)</th><th>P(≥4)</th></tr></thead><tbody>';
  for (const row of vtable) {
    htmlVirtual += `<tr><td>${row.turn}</td><td>${row.seen}</td><td>${pct(row.p1)}</td><td>${pct(row.p2)}</td><td>${pct(row.p3)}</td><td>${pct(row.p4)}</td></tr>`;
  }
  htmlVirtual += '</tbody></table></div>';
  elVirtual.innerHTML = htmlVirtual;

  // Colours
  const cols = new Set([...Object.keys(r.pipTotals), ...Object.keys(r.landSources)]);
  let htmlColors = '';
  htmlColors += '<div class="summary-section">';
  htmlColors += '<div class="summary-title">Colour pips vs land sources</div>';
  if (!cols.size) {
    htmlColors += '<p class="muted">No coloured mana symbols detected in mana costs yet.</p>';
  } else {
    htmlColors += '<p class="muted">Rule: every ~3 pips of a colour wants ~1 land source of that colour.</p>';
    htmlColors += '<table class="summary-table"><thead><tr><th>Colour</th><th>Pips</th><th>Needed</th><th>Sources</th><th>Δ</th></tr></thead><tbody>';
    for (const col of Array.from(cols).sort()) {
      const pips = r.pipTotals[col] || 0;
      const need = r.neededSources[col] || 0;
      const have = r.landSources[col] || 0;
      const d = r.deltaSources[col] || 0;
      htmlColors += `<tr><td>${col}</td><td>${pips}</td><td>${need}</td><td>${have}</td><td>${d>=0?'+':''}${d}</td></tr>`;
    }
    htmlColors += '</tbody></table>';
  }
  htmlColors += '</div>';
  elColors.innerHTML = htmlColors;

  setSummaryTab(state.summaryTab || 'overview');
  hookCurveHover();
}

// ----- curve graph + tooltip -----
function drawCurveGraph(r) {
  const svg = document.getElementById('curveSvg');
  if (!svg) return;
  const curve = r.curve;
  let maxCount = 0;
  for (let mv=0; mv<=10; mv++) if (curve[mv] > maxCount) maxCount = curve[mv];
  if (maxCount === 0) {
    svg.innerHTML = '';
    return;
  }
  const barWidth = 100 / 12;
  const bars = [];
  for (let mv=0; mv<=10; mv++) {
    const count = curve[mv] || 0;
    const h = (count / maxCount) * 80;
    const x = (mv + 0.5) * barWidth;
    const y = 90 - h;
    const colorIdx = mv % 6;
    const colorVar =
      colorIdx === 0 ? 'var(--curve-0)' :
      colorIdx === 1 ? 'var(--curve-1)' :
      colorIdx === 2 ? 'var(--curve-2)' :
      colorIdx === 3 ? 'var(--curve-3)' :
      colorIdx === 4 ? 'var(--curve-4)' :
      'var(--curve-5)';
    bars.push(`<rect data-mv="${mv}" x="${x - barWidth*0.4}" y="${y}" width="${barWidth*0.8}" height="${h}" rx="1.5" fill="${colorVar}" />`);
    bars.push(`<text x="${x}" y="96" font-size="4" text-anchor="middle" fill="var(--muted)">${mv}</text>`);
  }
  svg.innerHTML = `<rect x="0" y="10" width="100" height="80" fill="none" stroke="rgba(148,163,184,0.2)" />` + bars.join('');
}

function hookCurveHover() {
  const tooltip = document.getElementById('curveTooltip');
  const wrap = document.querySelector('.curve-graph-wrap');
  if (!wrap) return;
  wrap.onmousemove = null;
  wrap.onmouseleave = null;
  wrap.addEventListener('mousemove', e => {
    const target = e.target;
    const mvAttr = target.getAttribute && target.getAttribute('data-mv');
    if (!mvAttr) {
      tooltip.style.display = 'none';
      return;
    }
    const mv = parseInt(mvAttr,10);
    const entries = state.mvToNames[mv] || [];
    if (!entries.length) {
      tooltip.style.display = 'none';
      return;
    }
    const names = {};
    for (const ent of entries) names[ent.name] = (names[ent.name] || 0) + ent.qty;
    const lines = Object.entries(names).map(([n,q]) => `x${q} ${n}`);
    tooltip.innerHTML = `<b>MV ${mv}</b><br/>` + lines.join('<br/>');
    tooltip.style.display = 'block';
    const rect = wrap.getBoundingClientRect();
    tooltip.style.left = (e.clientX - rect.left + 10) + 'px';
    tooltip.style.top = (e.clientY - rect.top - 10) + 'px';
  });
  wrap.addEventListener('mouseleave', () => { tooltip.style.display = 'none'; });
}

// ----- deck view -----
function createPipRow(color_identity) {
  const container = document.createElement('div');
  container.className = 'pip-row';
  if (!color_identity || !color_identity.length) {
    const pip = document.createElement('span');
    pip.className = 'pip pip-C';
    pip.textContent = 'C';
    container.appendChild(pip);
    return container;
  }
  for (const col of color_identity) {
    const pip = document.createElement('span');
    pip.className = 'pip pip-' + col;
    pip.textContent = col;
    container.appendChild(pip);
  }
  return container;
}

function updateDeckCountsSummary() {
  const mainCount = Object.values(state.deckEntries).reduce((a,b)=>a+b,0);
  const sideCount = Object.values(state.sideEntries).reduce((a,b)=>a+b,0);
  document.getElementById('summaryBadge').textContent = `Main: ${mainCount} | Side: ${sideCount}`;
  document.getElementById('cardCountSummary').textContent = `Main ${mainCount} • Side ${sideCount}`;
}

function renderDeckView() {
  const container = document.getElementById('deckContainer');
  const viewMode = state.viewMode;
  const groupMode = state.groupMode;
  const zone = document.getElementById('mainSideMode').value || 'main';
  const cards = state.cardInfos;
  const sideNames = new Set(Object.keys(state.sideEntries));
  const mainNames = new Set(Object.keys(state.deckEntries));

  if (!cards.length && !sideNames.size) {
    container.innerHTML = '<div class="muted">No cards yet. Use the search above or paste a list.</div>';
    updateDeckCountsSummary();
    return;
  }

  updateDeckCountsSummary();
  container.innerHTML = '';

  const filtered = cards.filter(c => zone === 'main' ? mainNames.has(c.name) : sideNames.has(c.name));
  if (!filtered.length && zone === 'side') {
    container.innerHTML = '<div class="muted">No sideboard cards yet. Move cards here from the main deck.</div>';
    return;
  }

  const grouped = {};
  function groupKey(c) {
    if (groupMode === 'type') return (c.type_line || 'Other').split('—')[0].trim() || 'Other';
    if (groupMode === 'mv') return 'MV ' + c.mv;
    if (groupMode === 'color') {
      if (!c.color_identity || !c.color_identity.length) return 'Colorless';
      return c.color_identity.join('');
    }
    return zone === 'main' ? 'Main deck' : 'Sideboard';
  }
  for (const c of filtered) {
    const k = groupKey(c);
    if (!grouped[k]) grouped[k] = [];
    grouped[k].push(c);
  }
  const groups = Object.keys(grouped).sort((a,b)=>a.localeCompare(b));
  for (const gKey of groups) {
    const header = document.createElement('div');
    header.className = 'muted';
    header.style.margin = '4px 0 2px';
    header.textContent = gKey;
    container.appendChild(header);

    const list = grouped[gKey];
    if (viewMode === 'grid') {
      const grid = document.createElement('div');
      grid.className = 'deck-grid';
      for (const c of list) {
        const qty = zone === 'main' ? state.deckEntries[c.name] || 0 : state.sideEntries[c.name] || 0;
        if (!qty) continue;
        const div = document.createElement('div');
        div.className = 'deck-card';
        div.dataset.cardName = c.name;

        if (c.image_url) {
          const img = document.createElement('img');
          img.src = c.image_url;
          img.alt = c.name;
          div.appendChild(img);
        }

        const head = document.createElement('div');
        head.className = 'deck-card-header';
        const nameSpan = document.createElement('span');
        nameSpan.textContent = c.name;
        const qtySpan = document.createElement('span');
        qtySpan.className = 'qty-pill';
        const minusBtn = document.createElement('button');
        minusBtn.className = 'qty-btn';
        minusBtn.textContent = '−';
        minusBtn.addEventListener('click', e => { e.stopPropagation(); adjustQty(c.name, zone, -1); });
        const plusBtn = document.createElement('button');
        plusBtn.className = 'qty-btn';
        plusBtn.textContent = '+';
        plusBtn.addEventListener('click', e => { e.stopPropagation(); adjustQty(c.name, zone, +1); });
        const qtyText = document.createElement('span');
        qtyText.textContent = 'x' + qty;
        qtySpan.appendChild(minusBtn);
        qtySpan.appendChild(qtyText);
        qtySpan.appendChild(plusBtn);
        head.appendChild(nameSpan);
        head.appendChild(qtySpan);
        div.appendChild(head);

        const typeSpan = document.createElement('div');
        typeSpan.className = 'muted';
        typeSpan.style.fontSize = '0.75rem';
        typeSpan.textContent = (c.type_line || '').split('—')[0].trim();
        div.appendChild(typeSpan);

        const mvSpan = document.createElement('div');
        mvSpan.className = 'muted';
        mvSpan.style.fontSize = '0.75rem';
        mvSpan.textContent = `MV ${c.mv}`;
        div.appendChild(mvSpan);

        div.appendChild(createPipRow(c.color_identity));

        div.addEventListener('click', ()=>openCardModal(c.name, zone));
        grid.appendChild(div);
      }
      container.appendChild(grid);
    } else {
      for (const c of list) {
        const qty = zone === 'main' ? state.deckEntries[c.name] || 0 : state.sideEntries[c.name] || 0;
        if (!qty) continue;
        const row = document.createElement('div');
        row.className = 'deck-list-row';
        row.dataset.cardName = c.name;

        const qtyCell = document.createElement('div');
        const minusBtn = document.createElement('button');
        minusBtn.className = 'qty-btn';
        minusBtn.textContent = '−';
        minusBtn.addEventListener('click', e=>{e.stopPropagation();adjustQty(c.name, zone, -1);});
        const qtyText = document.createElement('span');
        qtyText.textContent = ' ' + qty + ' ';
        const plusBtn = document.createElement('button');
        plusBtn.className = 'qty-btn';
        plusBtn.textContent = '+';
        plusBtn.addEventListener('click', e=>{e.stopPropagation();adjustQty(c.name, zone, +1);});
        qtyCell.appendChild(minusBtn);
        qtyCell.appendChild(qtyText);
        qtyCell.appendChild(plusBtn);
        row.appendChild(qtyCell);

        const nameCell = document.createElement('div');
        nameCell.textContent = c.name;
        row.appendChild(nameCell);

        const typeCell = document.createElement('div');
        typeCell.innerHTML = `<span class="chip">${(c.type_line || '').split('—')[0].trim()}</span>`;
        row.appendChild(typeCell);

        const mvCell = document.createElement('div');
        mvCell.textContent = `MV ${c.mv}`;
        row.appendChild(mvCell);

        const zoneCell = document.createElement('div');
        zoneCell.innerHTML = `<button class="secondary" style="font-size:0.7rem;padding:3px 6px;" data-move="${c.name}">${zone==='main'?'→ Side':'→ Main'}</button>`;
        row.appendChild(zoneCell);

        row.addEventListener('click', e=>{
          if (e.target && e.target.getAttribute('data-move')) return;
          openCardModal(c.name, zone);
        });
        row.querySelector('[data-move]').addEventListener('click', e=>{
          e.stopPropagation();
          moveBetweenZones(c.name, zone);
        });

        container.appendChild(row);
      }
    }
  }
}

function adjustQty(name, zone, delta) {
  const map = zone === 'main' ? state.deckEntries : state.sideEntries;
  const value = (map[name] || 0) + delta;
  if (value <= 0) {
    delete map[name];
  } else {
    map[name] = value;
  }
  if (zone === 'main') rebuildDeckTextFromState();
  scheduleAnalyze();
}

function moveBetweenZones(name, fromZone) {
  const fromMap = fromZone === 'main' ? state.deckEntries : state.sideEntries;
  const toMap = fromZone === 'main' ? state.sideEntries : state.deckEntries;
  const qty = fromMap[name] || 0;
  if (!qty) return;
  delete fromMap[name];
  toMap[name] = (toMap[name] || 0) + qty;
  if (fromZone === 'main') rebuildDeckTextFromState();
  scheduleAnalyze();
}

// ----- status chip -----
function updateDeckStatusChip(result = null) {
  const chip = document.getElementById('deckStatusChip');
  const sizeTarget = parseInt(document.getElementById('deckSizeInput').value,10) || 60;
  const formatSel = document.getElementById('deckFormat').value;
  const deckSize = result ? result.deckSize : Object.values(state.deckEntries).reduce((a,b)=>a+b,0);

  let status = '';
  let cls = 'chip';

  if (!deckSize) {
    status = 'No cards yet';
  } else {
    const diff = deckSize - sizeTarget;
    const abs = Math.abs(diff);
    if (formatSel === 'constructed' && deckSize < 60) {
      status = `Invalid: ${deckSize}/60 for constructed`;
      cls += ' bad';
    } else if (formatSel === 'limited' && deckSize < 40) {
      status = `Invalid: ${deckSize}/40 for limited`;
      cls += ' bad';
    } else if (formatSel === 'commander' && deckSize !== 99 && deckSize !== 100) {
      status = `Warn: ${deckSize} cards; EDH is usually 99+1`;
      cls += ' warn';
    } else if (abs <= 2) {
      status = `${deckSize}/${sizeTarget} (within band)`;
      cls += ' ok';
    } else {
      status = `${deckSize}/${sizeTarget} (±${diff})`;
      cls += ' warn';
    }
  }

  chip.className = cls;
  chip.textContent = status;
}

// ----- modal -----
let modalCurrentName = null;
let modalCurrentZone = 'main';

function buildCardMiniSummary(card, profile) {
  const r = state.lastResult;
  const lines = [];
  const totalWeight = r ? r.deckWeight : null;
  const qty = (state.deckEntries[card.name] || 0);
  const weight = card.mv * qty;

  if (totalWeight && totalWeight > 0) {
    const pctWeight = (weight / totalWeight) * 100;
    lines.push(`Weight: MV ${card.mv} × ${qty} ≈ ${weight.toFixed(1)} (${pctWeight.toFixed(1)}% of nonland).`);
  } else {
    lines.push(`Weight: MV ${card.mv} × ${qty} = ${weight.toFixed(1)}.`);
  }

  if (profile.effMV !== null && profile.effMV !== undefined && !Number.isNaN(profile.effMV)) {
    lines.push(`Using override MV ${profile.effMV} (printed ${card.printed_mv}).`);
  }

  if (profile.rampType) {
    lines.push(`Ramp tag: ${profile.rampType} (counts as +1 virtual land, coarse).`);
  }
  if (profile.cantripExtra) {
    lines.push(`Cantrip: ~${profile.cantripExtra.toFixed(2)} extra cards per cast.`);
  }

  const plans = profile.plans || [];
  if (plans.length) lines.push(`Plans: ${plans.join(', ')}.`);

  const pe = profile.planEffMV || {};
  const overrides = Object.entries(pe).filter(([k,v]) => Number.isFinite(v));
  if (overrides.length) {
    lines.push('Plan MV overrides: ' + overrides.map(([k,v])=>`${k}:${v}`).join(', ') + '.');
  }

  return lines.join(' ');
}

function openCardModal(name, zone) {
  modalCurrentName = name;
  modalCurrentZone = zone || 'main';

  const card = state.cardInfos.find(c=>c.name===name);
  if (!card) return;
  const profile = state.tuning[name] || {};
  const qtyMain = state.deckEntries[name] || 0;
  const qtySide = state.sideEntries[name] || 0;
  const qty = modalCurrentZone === 'main' ? qtyMain : qtySide;

  document.getElementById('modalCardName').textContent = card.name;
  document.getElementById('modalCardType').textContent = card.type_line || '';
  const imgEl = document.getElementById('modalCardImg');
  if (card.image_url) { imgEl.src = card.image_url; imgEl.style.display=''; }
  else imgEl.style.display='none';

  document.getElementById('modalZone').value = modalCurrentZone;
  document.getElementById('modalQty').value = qty;

  const eff = profile.effMV;
  document.getElementById('modalEffMV').value = (eff!==undefined && eff!==null && !Number.isNaN(eff)) ? eff : '';

  document.getElementById('modalRampType').value = profile.rampType || '';
  document.getElementById('modalRampTurn').value = profile.rampTurn || '';
  document.getElementById('modalRampNet').value = (profile.rampNet!==undefined && profile.rampNet!==null) ? profile.rampNet : '';
  document.getElementById('modalCantrip').value = (profile.cantripExtra!==undefined && profile.cantripExtra!==null) ? profile.cantripExtra : '';

  const plans = profile.plans || [];
  document.getElementById('modalPlanA').checked = plans.includes('A');
  document.getElementById('modalPlanB').checked = plans.includes('B');
  document.getElementById('modalPlanC').checked = plans.includes('C');
  document.getElementById('modalPlanD').checked = plans.includes('D');
  document.getElementById('modalPlanE').checked = plans.includes('E');

  const pe = profile.planEffMV || {};
  document.getElementById('planEffA').value = Number.isFinite(pe.A)?pe.A:'';
  document.getElementById('planEffB').value = Number.isFinite(pe.B)?pe.B:'';
  document.getElementById('planEffC').value = Number.isFinite(pe.C)?pe.C:'';
  document.getElementById('planEffD').value = Number.isFinite(pe.D)?pe.D:'';
  document.getElementById('planEffE').value = Number.isFinite(pe.E)?pe.E:'';

  document.getElementById('modalSummary').textContent = buildCardMiniSummary(card, profile);
  document.getElementById('cardModalBackdrop').style.display = 'flex';
}
function closeCardModal() {
  document.getElementById('cardModalBackdrop').style.display = 'none';
  modalCurrentName = null;
}

function saveCardProfile() {
  if (!modalCurrentName) { closeCardModal(); return; }
  const name = modalCurrentName;
  const zone = document.getElementById('modalZone').value || 'main';
  const qtyRaw = document.getElementById('modalQty').value.trim();
  let qty = qtyRaw === '' ? 0 : Number(qtyRaw);
  if (!Number.isFinite(qty) || qty < 0) qty = 0;

  // move between zones if needed
  const newZone = zone;
  const prevZone = modalCurrentZone;
  if (prevZone !== newZone) {
    moveBetweenZones(name, prevZone);
  }
  const map = newZone === 'main' ? state.deckEntries : state.sideEntries;
  if (qty === 0) delete map[name];
  else map[name] = Math.round(qty);

  const effMVRaw = document.getElementById('modalEffMV').value.trim();
  const effMV = effMVRaw === '' ? null : Number(effMVRaw);
  const rampType = document.getElementById('modalRampType').value || null;
  const rampTurnRaw = document.getElementById('modalRampTurn').value.trim();
  const rampTurn = rampTurnRaw === '' ? null : Number(rampTurnRaw);
  const rampNetRaw = document.getElementById('modalRampNet').value.trim();
  const rampNet = rampNetRaw === '' ? null : Number(rampNetRaw);
  const cantripRaw = document.getElementById('modalCantrip').value.trim();
  const cantripExtra = cantripRaw === '' ? null : Number(cantripRaw);

  const plans = [];
  if (document.getElementById('modalPlanA').checked) plans.push('A');
  if (document.getElementById('modalPlanB').checked) plans.push('B');
  if (document.getElementById('modalPlanC').checked) plans.push('C');
  if (document.getElementById('modalPlanD').checked) plans.push('D');
  if (document.getElementById('modalPlanE').checked) plans.push('E');

  const planEffMV = {};
  function readPlan(id){ const v=document.getElementById(id).value.trim(); if(v==='')return null; const n=Number(v); return Number.isFinite(n)?n:null; }
  const vA=readPlan('planEffA'); const vB=readPlan('planEffB'); const vC=readPlan('planEffC'); const vD=readPlan('planEffD'); const vE=readPlan('planEffE');
  if (vA!==null) planEffMV.A=vA;
  if (vB!==null) planEffMV.B=vB;
  if (vC!==null) planEffMV.C=vC;
  if (vD!==null) planEffMV.D=vD;
  if (vE!==null) planEffMV.E=vE;

  const profile = {
    effMV: Number.isFinite(effMV)?effMV:null,
    rampType,
    rampTurn: Number.isFinite(rampTurn)?rampTurn:null,
    rampNet: Number.isFinite(rampNet)?rampNet:null,
    cantripExtra: Number.isFinite(cantripExtra)?cantripExtra:null,
    plans
  };
  if (Object.keys(planEffMV).length) profile.planEffMV = planEffMV;
  state.tuning[name] = profile;

  if (newZone === 'main') rebuildDeckTextFromState();
  closeCardModal();
  scheduleAnalyze();
}

document.getElementById('modalSaveBtn').addEventListener('click', saveCardProfile);
document.getElementById('closeModalBtn').addEventListener('click', saveCardProfile);
document.getElementById('cardModalBackdrop').addEventListener('click', e=>{
  if (e.target.id === 'cardModalBackdrop') saveCardProfile();
});

// ----- auto analyze debounce -----
let analyzeTimer = null;
function scheduleAnalyze() {
  clearTimeout(analyzeTimer);
  analyzeTimer = setTimeout(()=>{
    analyzeDeck().catch(err=>{
      console.error(err);
      document.getElementById('summaryError').textContent = String(err);
    });
  }, 300);
}

// ----- local storage decks -----
const STORAGE_KEY = 'coast_decks_v10';
function getSavedDecks() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return {};
    const obj = JSON.parse(raw);
    return typeof obj === 'object' && obj ? obj : {};
  } catch { return {}; }
}
function saveDeckLocally() {
  const name = document.getElementById('deckName').value.trim() || 'Untitled deck';
  const decks = getSavedDecks();
  decks[name] = {
    main: state.deckEntries,
    side: state.sideEntries,
    tuning: state.tuning,
    format: document.getElementById('deckFormat').value,
    targetSize: parseInt(document.getElementById('deckSizeInput').value,10) || 60,
    landCount: parseInt(document.getElementById('landCountInput').value,10) || 0,
    planSettings: state.planSettings
  };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(decks));
  showToast(`Saved deck "${name}" locally.`);
}
function openDecksModal() {
  const decks = getSavedDecks();
  const listEl = document.getElementById('decksList');
  const names = Object.keys(decks).sort();
  if (!names.length) {
    listEl.innerHTML = '(No decks saved yet.)';
  } else {
    let html = '<table class="summary-table"><thead><tr><th>Name</th><th>Format</th><th>Target</th><th></th></tr></thead><tbody>';
    for (const n of names) {
      const d = decks[n];
      html += `<tr><td>${n}</td><td>${d.format||'auto'}</td><td>${d.targetSize||'-'}</td><td><button class="secondary" data-load="${n}" style="font-size:0.7rem;padding:2px 6px;">Load</button> <button class="secondary" data-del="${n}" style="font-size:0.7rem;padding:2px 6px;">Delete</button></td></tr>`;
    }
    html += '</tbody></table>';
    listEl.innerHTML = html;
    listEl.querySelectorAll('[data-load]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        loadDeckByName(btn.getAttribute('data-load'));
      });
    });
    listEl.querySelectorAll('[data-del]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        deleteDeckByName(btn.getAttribute('data-del'));
      });
    });
  }
  document.getElementById('decksModalBackdrop').style.display = 'flex';
}
function closeDecksModal() {
  document.getElementById('decksModalBackdrop').style.display = 'none';
}
function loadDeckByName(name) {
  const decks = getSavedDecks();
  const data = decks[name];
  if (!data) return;
  state.deckEntries = data.main || {};
  state.sideEntries = data.side || {};
  state.tuning = data.tuning || {};
  state.planSettings = data.planSettings || state.planSettings;
  document.getElementById('deckName').value = name;
  document.getElementById('deckFormat').value = data.format || 'auto';
  document.getElementById('deckSizeInput').value = data.targetSize || 60;
  document.getElementById('landCountInput').value = data.landCount || 0;
  rebuildDeckTextFromState();
  closeDecksModal();
  show('deckApp'); hide('startScreen'); hide('landCalcApp');
  showToast(`Loaded deck "${name}".`);
  scheduleAnalyze();
}
function deleteDeckByName(name) {
  const decks = getSavedDecks();
  delete decks[name];
  localStorage.setItem(STORAGE_KEY, JSON.stringify(decks));
  openDecksModal();
  showToast(`Deleted deck "${name}".`);
}

// ----- plan panel -----
function shuffleInPlace(arr) {
  for (let i=arr.length-1;i>0;i--) {
    const j = Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]]=[arr[j],arr[i]];
  }
  return arr;
}

function renderPlanPanel() {
  const content = document.getElementById('planContent');
  const meta = document.getElementById('planMeta');
  const plan = state.activePlan;
  const settings = state.planSettings[plan] || {targetTurn:3};
  const targetTurn = settings.targetTurn || 3;
  document.getElementById('planTargetTurn').value = targetTurn;

  const cards = state.cardInfos;
  if (!cards.length) {
    content.innerHTML = '<div class="muted">(No deck yet. Tag cards with Plan A–E.)</div>';
    meta.textContent = '';
    return;
  }

  let deckSize = 0;
  for (const c of cards) deckSize += state.deckEntries[c.name] || 0;
  const planCards = [];
  for (const c of cards) {
    const profile = state.tuning[c.name] || {};
    const plans = profile.plans || [];
    const qty = state.deckEntries[c.name] || 0;
    if (!qty) continue;
    if (plans.includes(plan)) planCards.push({ card:c, profile, qty });
  }
  meta.textContent = `${planCards.length} card types tagged for Plan ${plan}, main-deck size ${deckSize}.`;
  if (!planCards.length) {
    content.innerHTML = `<div class="muted">(No cards currently tagged for Plan ${plan}.)</div>`;
    return;
  }

  let seen = 7 + (targetTurn-1);
  if (seen > deckSize) seen = deckSize;

  let planProbApprox = 1;
  const cardLines = [];
  for (const pc of planCards) {
    const K = pc.qty;
    const pSeen = probAtLeast(1, K, deckSize, seen);
    planProbApprox *= pSeen;
    cardLines.push({name:pc.card.name, qty:pc.qty, pSeen});
  }
  if (!Number.isFinite(planProbApprox)) planProbApprox = 0;

  // sample hand including plan cards
  const expanded = [];
  for (const pc of planCards) for (let i=0;i<pc.qty;i++) expanded.push(pc.card.name);
  shuffleInPlace(expanded);
  const handNames = expanded.slice(0,7);
  if (handNames.length < 7) {
    const all = [];
    for (const c of cards) for (let i=0;i<(state.deckEntries[c.name]||0);i++) all.push(c.name);
    shuffleInPlace(all);
    for (const n of all) { if (handNames.length>=7) break; handNames.push(n); }
  }

  // follow-up buckets (global, but using plan MV overrides for classification)
  let landCount = 0, cheapCount=0, midCount=0, bigCount=0;
  for (const c of cards) {
    const qty = state.deckEntries[c.name] || 0;
    if (!qty) continue;
    const isLand = (c.type_line || '').toLowerCase().includes('land');
    if (isLand) { landCount += qty; continue; }
    const profile = state.tuning[c.name] || {};
    const mvOverride = profile.planEffMV && profile.planEffMV[plan];
    const mvForBuckets = Number.isFinite(mvOverride) ? mvOverride : c.mv;
    if (mvForBuckets <= 2) cheapCount+=qty;
    else if (mvForBuckets <= 4) midCount+=qty;
    else bigCount+=qty;
  }
  const totalCards = landCount+cheapCount+midCount+bigCount || 1;
  const landPct = landCount/totalCards;
  const cheapPct = cheapCount/totalCards;
  const midPct = midCount/totalCards;
  const bigPct = bigCount/totalCards;

  const sorted = [...cardLines].sort((a,b)=>a.pSeen-b.pSeen);
  const worst1 = sorted[0];
  const worst2 = sorted[1];

  let html = '';
  html += '<div class="summary-title">Plan odds</div>';
  html += `<div class="muted">Approximate chance all Plan ${plan} pieces appear by turn ${targetTurn}: <b>${pct(planProbApprox)}</b> (naive independence).</div>`;
  html += '<table class="summary-table" style="margin-top:4px;"><thead><tr><th>Card</th><th>Copies</th><th>P(seen ≥1 by T)</th></tr></thead><tbody>';
  for (const cl of cardLines) {
    html += `<tr><td>${cl.name}</td><td>${cl.qty}</td><td>${pct(cl.pSeen)}</td></tr>`;
  }
  html += '</tbody></table>';

  html += '<div class="summary-title" style="margin-top:6px;">Wishlist hand (example)</div>';
  html += '<div class="plan-hand">';
  for (const n of handNames) html += `<div class="plan-hand-card">${n}</div>`;
  html += '</div>';

  html += '<div class="summary-title" style="margin-top:6px;">Likely follow-up draws (whole deck)</div>';
  html += `<div class="muted">Land: <b>${pct(landPct)}</b> • 1–2 MV: <b>${pct(cheapPct)}</b> • 3–4 MV: <b>${pct(midPct)}</b> • 5+: <b>${pct(bigPct)}</b></div>`;

  html += '<div class="summary-title" style="margin-top:6px;">Bottlenecks</div>';
  html += '<ul style="padding-left:18px;margin-top:2px;" class="muted">';
  if (worst1) html += `<li>${worst1.name}: only ${pct(worst1.pSeen)} to show by T${targetTurn}.</li>`;
  if (worst2) html += `<li>${worst2.name}: only ${pct(worst2.pSeen)} to show by T${targetTurn}.</li>`;
  html += '</ul>';

  content.innerHTML = html;
}

// ----- standalone land calc -----
function runLandCalc() {
  const N = parseInt(document.getElementById('lcDeckSize').value,10) || 60;
  const K = parseInt(document.getElementById('lcLandCount').value,10) || 24;
  const maxTurn = parseInt(document.getElementById('lcMaxTurn').value,10) || 5;
  const pd = document.getElementById('lcPlayDraw').value;
  const resultsEl = document.getElementById('lcResults');

  let txt = '';
  txt += `Deck size: ${N}, lands: ${K}, on the ${pd==='play'?'play':'draw'}\n\n`;
  txt += `Turn  Seen  P(≥1)   P(≥2)   P(≥3)   P(≥4)\n`;
  for (let t=1;t<=maxTurn;t++) {
    let seen = 7 + (t-1) + (pd==='draw'?1:0);
    if (seen > N) seen = N;
    const p1 = probAtLeast(1, K, N, seen);
    const p2 = probAtLeast(2, K, N, seen);
    const p3 = probAtLeast(3, K, N, seen);
    const p4 = probAtLeast(4, K, N, seen);
    txt += `${String(t).padStart(4)}  ${String(seen).padStart(4)}  ${pct(p1).padStart(6)}  ${pct(p2).padStart(6)}  ${pct(p3).padStart(6)}  ${pct(p4).padStart(6)}\n`;
  }
  resultsEl.textContent = txt;
}

// ----- wiring -----
document.getElementById('btnBuild').addEventListener('click', ()=>{
  hide('startScreen'); show('deckApp'); hide('landCalcApp');
  state.mode = 'build';
  document.getElementById('builderMode').value = 'build';
  document.getElementById('builderTitle').textContent = 'Deck builder';
});
document.getElementById('btnImport').addEventListener('click', ()=>{
  hide('startScreen'); show('deckApp'); hide('landCalcApp');
  state.mode = 'import';
  document.getElementById('builderMode').value = 'import';
  document.getElementById('builderTitle').textContent = 'Deck importer';
  rebuildDeckTextFromState();
  show('importControls'); hide('buildControls');
});
document.getElementById('btnLandCalc').addEventListener('click', ()=>{
  hide('startScreen'); hide('deckApp'); show('landCalcApp');
});
document.getElementById('backToHome').addEventListener('click', ()=>{
  show('startScreen'); hide('deckApp'); hide('landCalcApp');
});
document.getElementById('backFromLand').addEventListener('click', ()=>{
  show('startScreen'); hide('deckApp'); hide('landCalcApp');
});

document.getElementById('builderMode').addEventListener('change', e=>{
  const mode = e.target.value;
  state.mode = mode;
  if (mode==='build') { show('buildControls'); hide('importControls'); document.getElementById('builderTitle').textContent='Deck builder'; }
  else { hide('buildControls'); show('importControls'); document.getElementById('builderTitle').textContent='Deck importer'; rebuildDeckTextFromState(); }
});

document.getElementById('mainSideMode').addEventListener('change', ()=>{
  renderDeckView();
});

document.getElementById('cardSearchName').addEventListener('keydown', e=>{
  if (e.key==='Enter') document.getElementById('addCardBtn').click();
});
document.getElementById('addCardBtn').addEventListener('click', async ()=>{
  const name = document.getElementById('cardSearchName').value.trim();
  const qty = parseInt(document.getElementById('cardSearchQty').value,10) || 1;
  const status = document.getElementById('builderStatus');
  if (!name) { status.textContent = 'Enter a card name.'; return; }
  status.textContent = 'Searching Scryfall…';
  try {
    const info = await fetchCardData(name, 'fuzzy');
    const actual = info.name || name;
    const zone = document.getElementById('mainSideMode').value || 'main';
    const map = zone === 'main' ? state.deckEntries : state.sideEntries;
    map[actual] = (map[actual] || 0) + qty;
    document.getElementById('cardSearchName').value = '';
    document.getElementById('cardSearchQty').value = '1';
    status.textContent = `Added ${qty}× ${actual} to ${zone}.`;
    if (zone==='main') rebuildDeckTextFromState();
    scheduleAnalyze();
  } catch (err) {
    console.error(err);
    status.textContent = 'Failed to add card.';
  }
});

document.getElementById('deckText').addEventListener('input', e=>{
  const text = e.target.value;
  const entries = deckEntriesFromText(text);
  state.deckEntries = entries;
  const count = Object.values(entries).reduce((a,b)=>a+b,0);
  if (count>0) document.getElementById('builderStatus').textContent = `Deck from text: ${count} cards.`;
  else document.getElementById('builderStatus').textContent = 'No cards parsed from text.';
  scheduleAnalyze();
});
document.getElementById('deckText').addEventListener('blur', e=>{
  const entries = deckEntriesFromText(e.target.value);
  const count = Object.values(entries).reduce((a,b)=>a+b,0);
  if (count>0) showToast(`Imported deck from text (${count} cards).`);
});

document.getElementById('viewMode').addEventListener('change', e=>{
  state.viewMode = e.target.value;
  renderDeckView();
});
document.getElementById('groupMode').addEventListener('change', e=>{
  state.groupMode = e.target.value;
  renderDeckView();
});
document.getElementById('landViewMode').addEventListener('change', e=>{
  state.landViewMode = e.target.value;
  if (state.lastResult) renderSummary(state.lastResult);
});

document.getElementById('deckSizeInput').addEventListener('input', ()=>{
  updateDeckStatusChip(state.lastResult);
});
document.getElementById('landCountInput').addEventListener('input', ()=>{
  scheduleAnalyze();
});
document.getElementById('deckFormat').addEventListener('change', ()=>{
  scheduleAnalyze();
});

document.getElementById('saveDeckBtn').addEventListener('click', saveDeckLocally);
document.getElementById('openDecksBtn').addEventListener('click', openDecksModal);
document.getElementById('closeDecksBtn').addEventListener('click', closeDecksModal);
document.getElementById('decksModalBackdrop').addEventListener('click', e=>{
  if (e.target.id==='decksModalBackdrop') closeDecksModal();
});

document.querySelectorAll('[data-summary-tab-btn]').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const tab = btn.getAttribute('data-summary-tab-btn');
    setSummaryTab(tab);
  });
});

document.querySelectorAll('.plan-tab-btn').forEach(btn=>{
  btn.addEventListener('click', ()=>{
    const plan = btn.dataset.plan;
    state.activePlan = plan;
    document.querySelectorAll('.plan-tab-btn').forEach(b=>b.classList.toggle('active', b.dataset.plan===plan));
    const settings = state.planSettings[plan] || {targetTurn:3};
    document.getElementById('planTargetTurn').value = settings.targetTurn || 3;
    renderPlanPanel();
  });
});
document.getElementById('planTargetTurn').addEventListener('input', e=>{
  const v = parseInt(e.target.value,10);
  const plan = state.activePlan;
  if (!state.planSettings[plan]) state.planSettings[plan]={targetTurn:3};
  if (Number.isFinite(v) && v>=1) {
    state.planSettings[plan].targetTurn = v;
    renderPlanPanel();
  }
});

document.getElementById('toggleAboutBtn').addEventListener('click', ()=>{
  const content = document.getElementById('aboutContent');
  const btn = document.getElementById('toggleAboutBtn');
  const isHidden = content.style.display === 'none' || !content.style.display;
  content.style.display = isHidden ? 'block' : 'none';
  btn.textContent = isHidden ? 'Hide details' : 'Show details';
});

document.getElementById('lcCalcBtn').addEventListener('click', runLandCalc);

// init
setTheme('dark');
setSummaryTab('overview');
updateDeckCountsSummary();
</script>
</body>
</html>
